{
	"aho_corasick": {
		"scope": "rust",
		"prefix": "aho_corasick",
		"body": [
			"$0",
			"#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]",
			"pub struct Vertex<const K: usize> {",
			"    // can be changed to \"go\" if first all strings are added",
			"    next: [usize; K],",
			"    output: bool,",
			"    parent: usize,",
			"    parent_char: usize,",
			"    link: usize,",
			"    go: [usize; K],",
			"    depth: usize,",
			"}",
			"impl<const K: usize> Vertex<K> {",
			"    pub fn new(parent: usize, parent_char: usize, depth: usize) -> Self {",
			"        Self {",
			"            go: [usize::MAX; K],",
			"            link: usize::MAX,",
			"            next: [usize::MAX; K],",
			"            output: false,",
			"            depth,",
			"            parent,",
			"            parent_char,",
			"        }",
			"    }",
			"}",
			"",
			"pub type LAhoCorasick = AhoCorasick<26>;",
			"#[derive(Clone, Debug)]",
			"pub struct AhoCorasick<const K: usize> {",
			"    pub vertices: Vec<Vertex<K>>,",
			"}",
			"impl<const K: usize> AhoCorasick<K> {",
			"    pub fn new() -> Self {",
			"        Self {",
			"            vertices: vec![Vertex::new(usize::MAX, usize::MAX, 0)],",
			"        }",
			"    }",
			"",
			"    pub fn add_string(&mut self, s: &[usize]) -> usize {",
			"        let mut v = 0;",
			"        for c in s {",
			"            if self.vertices[v].next[*c] == usize::MAX {",
			"                self.vertices[v].next[*c] = self.vertices.len();",
			"                self.vertices",
			"                    .push(Vertex::new(v, *c, self.vertices[v].depth + 1));",
			"            }",
			"            v = self.vertices[v].next[*c];",
			"        }",
			"        self.vertices[v].output = true;",
			"        v",
			"    }",
			"",
			"    pub fn go(&mut self, v: usize, c: usize) -> usize {",
			"        if self.vertices[v].go[c] == usize::MAX {",
			"            if self.vertices[v].next[c] != usize::MAX {",
			"                self.vertices[v].go[c] = self.vertices[v].next[c];",
			"            } else {",
			"                self.vertices[v].go[c] = if v == 0 {",
			"                    0",
			"                } else {",
			"                    let l = self.get_link(v);",
			"                    self.go(l, c)",
			"                };",
			"            }",
			"        }",
			"        self.vertices[v].go[c]",
			"    }",
			"",
			"    fn get_link(&mut self, v: usize) -> usize {",
			"        if self.vertices[v].link == usize::MAX {",
			"            if v == 0 || self.vertices[v].parent == 0 {",
			"                self.vertices[v].link = 0;",
			"            } else {",
			"                let l = self.get_link(self.vertices[v].parent);",
			"                self.vertices[v].link = self.go(l, self.vertices[v].parent_char);",
			"            }",
			"        }",
			"        self.vertices[v].link",
			"    }",
			"}",
		]
	},
	"combinatorics": {
		"scope": "rust",
		"prefix": "combinatorics",
		"body": [
			"$0",
			"static mut SEEN: Vec<(N, N)> = Vec::new();",
			"",
			"#[allow(static_mut_refs)]",
			"fn get_seen() -> &'static mut Vec<(N, N)> {",
			"    unsafe { &mut SEEN }",
			"}",
			"",
			"/// use `init_seen` to get initial \"dp\" memoization table, doubles size on miss (why not)",
			"pub trait Combinatorics {",
			"    fn choose(self, k: usize) -> N;",
			"    fn fact(self) -> N;",
			"    fn inv_fact(self) -> N;",
			"}",
			"impl Combinatorics for usize {",
			"    fn choose(self, k: usize) -> N {",
			"        if self < k {",
			"            N::ZERO",
			"        } else {",
			"            self.fact() * (self - k).inv_fact() * k.inv_fact()",
			"        }",
			"    }",
			"    fn fact(self) -> N {",
			"        let seen = get_seen();",
			"        while self >= seen.len() {",
			"            init_seen(seen);",
			"        }",
			"        seen[self].0",
			"    }",
			"    fn inv_fact(self) -> N {",
			"        let seen = get_seen();",
			"        while self >= seen.len() {",
			"            init_seen(seen);",
			"        }",
			"        seen[self].1",
			"    }",
			"}",
			"fn init_seen(seen: &mut Vec<(N, N)>) {",
			"    if seen.is_empty() {",
			"        seen.push((N::ONE, N::ONE));",
			"    }",
			"    let mut cur = seen.l().0;",
			"    let mut cur_inv = seen.l().1;",
			"    for i in seen.len()..seen.len() * 2 {",
			"        cur *= N::new(i);",
			"        cur_inv /= N::new(i);",
			"        seen.push((cur, cur_inv));",
			"    }",
			"}",
		]
	},
	"comparator": {
		"scope": "rust",
		"prefix": "comparator",
		"body": [
			"$0",
			"#[derive(Debug)]",
			"struct Comparator(compile_error!());",
			"impl PartialEq for Comparator {",
			"    fn eq(&self, other: &Self) -> bool {",
			"        self.cmp(other).is_eq()",
			"    }",
			"}",
			"impl Eq for Comparator {}",
			"impl Ord for Comparator {",
			"    fn cmp(&self, other: &Self) -> std::cmp::Ordering {",
			"        todo!()",
			"    }",
			"}",
			"impl PartialOrd for Comparator {",
			"    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {",
			"        Some(self.cmp(other))",
			"    }",
			"}",
		]
	},
	"complex": {
		"scope": "rust",
		"prefix": "complex",
		"body": [
			"$0",
			"use std::ops::*;",
			"pub type CT = f64;",
			"fn sqrt(x: CT) -> CT {",
			"    x.sqrt()",
			"}",
			"fn sin_cos(x: CT) -> (CT, CT) {",
			"    x.sin_cos()",
			"}",
			"const PI: CT = std::f64::consts::PI;",
			"",
			"#[derive(Clone, Copy, PartialEq)]",
			"pub struct Complex(pub CT, pub CT);",
			"impl std::fmt::Debug for Complex {",
			"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
			"        write!(f, \"{} + {}i\", self.0, self.1)",
			"    }",
			"}",
			"impl Complex {",
			"    pub const ZERO: Complex = Complex(0., 0.);",
			"    pub const ONE: Complex = Complex(1., 0.);",
			"    pub const I: Complex = Complex(0., 1.);",
			"",
			"    pub fn len_sq(&self) -> CT {",
			"        self.0 * self.0 + self.1 * self.1",
			"    }",
			"",
			"    pub fn len(&self) -> CT {",
			"        sqrt(self.len_sq())",
			"    }",
			"}",
			"impl Add for Complex {",
			"    type Output = Self;",
			"",
			"    fn add(self, rhs: Self) -> Self::Output {",
			"        Self(self.0 + rhs.0, self.1 + rhs.1)",
			"    }",
			"}",
			"impl Add<CT> for Complex {",
			"    type Output = Self;",
			"",
			"    fn add(self, rhs: CT) -> Self::Output {",
			"        Self(self.0 + rhs, self.1)",
			"    }",
			"}",
			"impl Sub for Complex {",
			"    type Output = Self;",
			"",
			"    fn sub(self, rhs: Self) -> Self::Output {",
			"        Self(self.0 - rhs.0, self.1 - rhs.1)",
			"    }",
			"}",
			"impl Sub<CT> for Complex {",
			"    type Output = Self;",
			"",
			"    fn sub(self, rhs: CT) -> Self::Output {",
			"        Self(self.0 - rhs, self.1)",
			"    }",
			"}",
			"impl Mul for Complex {",
			"    type Output = Self;",
			"",
			"    fn mul(self, rhs: Self) -> Self::Output {",
			"        Self(",
			"            self.0 * rhs.0 - self.1 * rhs.1,",
			"            self.0 * rhs.1 + self.1 * rhs.0,",
			"        )",
			"    }",
			"}",
			"impl Mul<CT> for Complex {",
			"    type Output = Self;",
			"",
			"    fn mul(self, rhs: CT) -> Self::Output {",
			"        Self(self.0 * rhs, self.1 * rhs)",
			"    }",
			"}",
			"impl Div for Complex {",
			"    type Output = Self;",
			"",
			"    fn div(self, rhs: Self) -> Self::Output {",
			"        self * Self(rhs.0, -rhs.1) / rhs.len_sq()",
			"    }",
			"}",
			"impl Div<CT> for Complex {",
			"    type Output = Self;",
			"",
			"    fn div(self, rhs: CT) -> Self::Output {",
			"        Self(self.0 / rhs, self.1 / rhs)",
			"    }",
			"}",
			"impl Neg for Complex {",
			"    type Output = Complex;",
			"",
			"    fn neg(self) -> Self::Output {",
			"        Complex(-self.0, -self.1)",
			"    }",
			"}",
			"impl Neg for &Complex {",
			"    type Output = Complex;",
			"",
			"    fn neg(self) -> Self::Output {",
			"        Complex(-self.0, -self.1)",
			"    }",
			"}",
			"macro_rules! impl_complex_rest {",
			"    (\\$(\\$trait:ident::\\$fn:ident:\\$trait_assign:ident::\\$fn_assign:ident;)*) => {",
			"        \\$(",
			"            impl \\$trait<&Complex> for Complex {",
			"                type Output = Complex;",
			"",
			"                fn \\$fn(self, rhs: &Complex) -> Self::Output {",
			"                    \\$trait::\\$fn(self, *rhs)",
			"                }",
			"            }",
			"            impl \\$trait<&Complex> for &Complex {",
			"                type Output = Complex;",
			"",
			"                fn \\$fn(self, rhs: &Complex) -> Self::Output {",
			"                    \\$trait::\\$fn(*self, *rhs)",
			"                }",
			"            }",
			"            impl \\$trait<Complex> for &Complex {",
			"                type Output = Complex;",
			"",
			"                fn \\$fn(self, rhs: Complex) -> Self::Output {",
			"                    \\$trait::\\$fn(*self, rhs)",
			"                }",
			"            }",
			"            impl \\$trait<&CT> for Complex {",
			"                type Output = Complex;",
			"",
			"                fn \\$fn(self, rhs: &CT) -> Self::Output {",
			"                    \\$trait::\\$fn(self, *rhs)",
			"                }",
			"            }",
			"            impl \\$trait<&CT> for &Complex {",
			"                type Output = Complex;",
			"",
			"                fn \\$fn(self, rhs: &CT) -> Self::Output {",
			"                    \\$trait::\\$fn(*self, *rhs)",
			"                }",
			"            }",
			"            impl \\$trait<CT> for &Complex {",
			"                type Output = Complex;",
			"",
			"                fn \\$fn(self, rhs: CT) -> Self::Output {",
			"                    \\$trait::\\$fn(*self, rhs)",
			"                }",
			"            }",
			"            impl \\$trait_assign for Complex {",
			"                fn \\$fn_assign(&mut self, rhs: Complex) {",
			"                    *self = \\$trait::\\$fn(*self, rhs);",
			"                }",
			"            }",
			"            impl \\$trait_assign<&Complex> for Complex {",
			"                fn \\$fn_assign(&mut self, rhs: &Complex) {",
			"                    *self = \\$trait::\\$fn(*self, rhs);",
			"                }",
			"            }",
			"            impl \\$trait_assign<CT> for Complex {",
			"                fn \\$fn_assign(&mut self, rhs: CT) {",
			"                    *self = \\$trait::\\$fn(*self, rhs);",
			"                }",
			"            }",
			"            impl \\$trait_assign<&CT> for Complex {",
			"                fn \\$fn_assign(&mut self, rhs: &CT) {",
			"                    *self = \\$trait::\\$fn(*self, rhs);",
			"                }",
			"            }",
			"        )*",
			"    };",
			"}",
			"impl_complex_rest! {",
			"    Add::add:AddAssign::add_assign;",
			"    Sub::sub:SubAssign::sub_assign;",
			"    Mul::mul:MulAssign::mul_assign;",
			"    Div::div:DivAssign::div_assign;",
			"}",
		]
	},
	"dfs_low_mem": {
		"scope": "rust",
		"prefix": "dfs_low_mem",
		"body": [
			"$0",
			"pub fn dfs(u: U, edges: &Vec<Vec<U>>, dfsin: &mut Vec<U>, dfsout: &mut Vec<U>, t: &mut U) {",
			"    let mut todo = vec![(u, vec![])];",
			"    while let Some((u, mut vv)) = todo.pop() {",
			"        dfsin[u] = *t;",
			"        *t += 1;",
			"",
			"        if edges[u].is_empty() {",
			"            dfsout[u] = *t;",
			"            *t += 1;",
			"            for v in vv.into_iter().rev() {",
			"                dfsout[v] = *t;",
			"                *t += 1;",
			"            }",
			"        } else {",
			"            vv.push(u);",
			"            let mut todo2 = vec![];",
			"            for v in &edges[u] {",
			"                if *v == edges[u].l() {",
			"                    todo2.push((*v, vv));",
			"                    break;",
			"                } else {",
			"                    todo2.push((*v, vec![]));",
			"                }",
			"            }",
			"            todo2.reverse();",
			"            todo.extend(todo2);",
			"        }",
			"    }",
			"}",
		]
	},
	"direct_planar_graph": {
		"scope": "rust",
		"prefix": "direct_planar_graph",
		"body": [
			"$0",
			"// edges must be Vec<HashMap<usize, cost>>",
			"// degree must be mutable",
			"",
			"let mut lowest_degrees = Vec::new();",
			"for i in 0..n {",
			"    if degree[i] <= 5 {",
			"        lowest_degrees.push(i);",
			"    }",
			"}",
			"while let Some(u) = lowest_degrees.pop() {",
			"    for (v, _c) in edges[u].clone() {",
			"        edges[v].remove(&u);",
			"        degree[v] -= 1;",
			"        if degree[v] == 5 {",
			"            lowest_degrees.push(v);",
			"        }",
			"    }",
			"}",
		]
	},
	"fenwick_tree": {
		"scope": "rust",
		"prefix": "fenwick_tree",
		"body": [
			"$0",
			"pub struct FenwickTree {",
			"    tree: Vec<FenwickTreeType>,",
			"}",
			"impl FenwickTree {",
			"    pub fn new(n: usize) -> Self {",
			"        Self {",
			"            tree: vec![DEFAULT; n],",
			"        }",
			"    }",
			"",
			"    pub fn query(&self, mut i: usize) -> FenwickTreeType {",
			"        i += 1;",
			"        let mut sum = 0;",
			"        while i > 0 {",
			"            sum += self.tree[i - 1];",
			"            i -= ((i as isize) & -(i as isize)) as usize;",
			"        }",
			"        sum",
			"    }",
			"",
			"    pub fn update(&mut self, mut i: usize, v: FenwickTreeType) {",
			"        i += 1;",
			"        while i <= self.tree.len() {",
			"            self.tree[i - 1] += v;",
			"            i += ((i as isize) & -(i as isize)) as usize;",
			"        }",
			"    }",
			"}",
			"type FenwickTreeType = I;",
			"const DEFAULT: FenwickTreeType = FenwickTreeType::default();",
		]
	},
	"fft": {
		"scope": "rust",
		"prefix": "fft",
		"body": [
			"$0",
			"// requires Complex",
			"",
			"// from: https://cp-algorithms.com/algebra/fft.html#improved-implementation-in-place-computation",
			"pub fn fft(a: &mut Vec<Complex>, invert: bool) {",
			"    let n = a.len();",
			"",
			"    let mut j = 0;",
			"    for i in 1..n {",
			"        let mut bit = n >> 1;",
			"        while j & bit != 0 {",
			"            j ^= bit;",
			"            bit >>= 1;",
			"        }",
			"        j ^= bit;",
			"        if i < j {",
			"            a.swap(i, j);",
			"        }",
			"    }",
			"",
			"    let mut len = 2;",
			"    while len <= n {",
			"        let ang = 2. * PI / len as CT * if invert { -1. } else { 1. };",
			"        let (s, c) = sin_cos(ang);",
			"        let wlen = Complex(c, s);",
			"        for i in (0..n).step_by(len) {",
			"            let mut w = Complex::ONE;",
			"            for j in 0..len / 2 {",
			"                let u = a[i + j];",
			"                let v = a[i + j + len / 2] * w;",
			"                a[i + j] = u + v;",
			"                a[i + j + len / 2] = u - v;",
			"                w *= wlen;",
			"            }",
			"        }",
			"",
			"        len <<= 1;",
			"    }",
			"",
			"    if invert {",
			"        for x in a {",
			"            *x /= n as CT;",
			"        }",
			"    }",
			"}",
			"",
			"pub fn multiply(a: &Vec<isize>, b: &Vec<isize>) -> Vec<isize> {",
			"    let mut result = multiply_complex(",
			"        &a.iter().map(|x| Complex(*x as CT, 0.)).cv(),",
			"        &b.iter().map(|x| Complex(*x as CT, 0.)).cv(),",
			"    )",
			"    .into_iter()",
			"    .map(|x| x.0.round() as I)",
			"    .cv();",
			"    while result.len() > 1 && result.last().unwrap() == &0 {",
			"        result.pop().unwrap();",
			"    }",
			"    result",
			"}",
			"",
			"pub fn multiply_complex(a: &Vec<Complex>, b: &Vec<Complex>) -> Vec<Complex> {",
			"    let mut fa = a.clone();",
			"    let mut fb = b.clone();",
			"    let n = (a.len() + b.len()).next_power_of_two();",
			"",
			"    fa.resize(n, Complex::ZERO);",
			"    fb.resize(n, Complex::ZERO);",
			"",
			"    fft(&mut fa, false);",
			"    fft(&mut fb, false);",
			"    for (fai, fbi) in fa.iter_mut().zip(fb) {",
			"        *fai *= fbi;",
			"    }",
			"    fft(&mut fa, true);",
			"",
			"    fa",
			"}",
		]
	},
	"good_primes.txt": {
		"scope": "rust",
		"prefix": "good_primes.txt",
		"body": [
			"$0",
			"type N = Mod<156859239850691603>;",
			"const K: N = N::new(3414519959);",
		]
	},
	"graph": {
		"scope": "rust",
		"prefix": "graph",
		"body": [
			"$0",
			"let mut edges = vec![vec![]; n];",
			"for _ in 1..n {",
			"    let (u, v) = r!(usize, usize);",
			"    edges[u - 1].push(v - 1);",
			"    edges[v - 1].push(u - 1);",
			"}",
		]
	},
	"hld": {
		"scope": "rust",
		"prefix": "hld",
		"body": [
			"$0",
			"use std::mem::swap;",
			"",
			"pub struct Hld {",
			"    heavy: Vec<usize>,",
			"    in_num: Vec<usize>,",
			"    out_num: Vec<usize>,",
			"    light: Vec<usize>,",
			"    depth: Vec<usize>,",
			"}",
			"impl Hld {",
			"    fn max_subtree(",
			"        u: usize,",
			"        graph: &mut Vec<Vec<usize>>,",
			"        subtree_sizes: &mut Vec<usize>,",
			"        max: &mut Vec<usize>,",
			"        light: &mut Vec<usize>,",
			"        depth: &mut Vec<usize>,",
			"    ) {",
			"        subtree_sizes[u] = 0;",
			"        for i in (0..graph[u].len()).rev() {",
			"            let v = graph[u][i];",
			"            if depth[v] != usize::MAX {",
			"                if max[u] == graph[u].len() - 1 {",
			"                    max[u] = i;",
			"                }",
			"                graph[u].swap_remove(i);",
			"                continue;",
			"            }",
			"            light[v] = u;",
			"            depth[v] = depth[u] + 1;",
			"            Self::max_subtree(v, graph, subtree_sizes, max, light, depth);",
			"            subtree_sizes[u] += subtree_sizes[v];",
			"            if subtree_sizes[graph[u][max[u]]] < subtree_sizes[v] {",
			"                max[u] = i;",
			"            }",
			"        }",
			"    }",
			"",
			"    fn hld(",
			"        u: usize,",
			"        graph: &Vec<Vec<usize>>,",
			"        max: &Vec<usize>,",
			"        in_num: &mut Vec<usize>,",
			"        out_num: &mut Vec<usize>,",
			"        heavy: &mut Vec<usize>,",
			"        ctr: &mut usize,",
			"    ) {",
			"        in_num[u] = *ctr;",
			"        *ctr += 1;",
			"",
			"        if !graph[u].is_empty() {",
			"            heavy[graph[u][max[u]]] = heavy[u];",
			"            Self::hld(graph[u][max[u]], graph, max, in_num, out_num, heavy, ctr);",
			"        }",
			"        for (i, v) in graph[u].iter().enumerate() {",
			"            if max[u] == i {",
			"                continue;",
			"            };",
			"            heavy[*v] = *v;",
			"            Self::hld(*v, graph, max, in_num, out_num, heavy, ctr);",
			"        }",
			"",
			"        out_num[u] = *ctr;",
			"    }",
			"",
			"    pub fn new(mut graph: Vec<Vec<usize>>) -> Self {",
			"        let n = graph.len();",
			"        let mut subtree_sizes = vec![0; n];",
			"        let mut max = vec![0; n];",
			"        let mut light = vec![0; n];",
			"        let mut depth = vec![usize::MAX; n];",
			"        depth[0] = 0;",
			"        Self::max_subtree(",
			"            0,",
			"            &mut graph,",
			"            &mut subtree_sizes,",
			"            &mut max,",
			"            &mut light,",
			"            &mut depth,",
			"        );",
			"        let mut in_num = subtree_sizes; // reuse :)",
			"        let mut out_num = vec![0; n];",
			"        let mut heavy = vec![0; n];",
			"        Self::hld(",
			"            0,",
			"            &graph,",
			"            &max,",
			"            &mut in_num,",
			"            &mut out_num,",
			"            &mut heavy,",
			"            &mut 0,",
			"        );",
			"",
			"        Self {",
			"            in_num,",
			"            out_num,",
			"            heavy,",
			"            light,",
			"            depth,",
			"        }",
			"    }",
			"",
			"    fn is_ancestor(&self, a: usize, b: usize) -> bool {",
			"        self.in_num[a] <= self.in_num[b] && self.out_num[b] <= self.out_num[a]",
			"    }",
			"",
			"    pub fn query(&self, mut a: usize, mut b: usize) -> Vec<(usize, usize)> {",
			"        let mut segments = vec![];",
			"        while a != b {",
			"            if self.is_ancestor(b, a) {",
			"                swap(&mut a, &mut b);",
			"            }",
			"            if self.is_ancestor(a, b) && self.is_ancestor(self.heavy[b], a) {",
			"                // a is on the heavy path from b",
			"                segments.push((self.in_num[a], self.in_num[b]));",
			"                b = a;",
			"                continue;",
			"            }",
			"            if self.depth[self.heavy[a]] < self.depth[self.heavy[b]] {",
			"                swap(&mut a, &mut b);",
			"            }",
			"            segments.push((self.in_num[self.heavy[a]], self.in_num[a]));",
			"            a = self.light[self.heavy[a]];",
			"        }",
			"        if !segments",
			"            .last()",
			"            .is_some_and(|x| x.0 == self.in_num[a] || x.1 == self.in_num[a])",
			"        {",
			"            segments.push((self.in_num[a], self.in_num[a]));",
			"        }",
			"        segments",
			"    }",
			"",
			"    pub fn lca(&self, mut a: usize, mut b: usize) -> usize {",
			"        while a != b {",
			"            if self.is_ancestor(b, a) {",
			"                swap(&mut a, &mut b);",
			"            }",
			"            if self.is_ancestor(a, b) && self.is_ancestor(self.heavy[b], a) {",
			"                // a is on the heavy path from b",
			"                b = a;",
			"                continue;",
			"            }",
			"            if self.depth[self.heavy[a]] < self.depth[self.heavy[b]] {",
			"                swap(&mut a, &mut b);",
			"            }",
			"            a = self.light[self.heavy[a]];",
			"        }",
			"        a",
			"    }",
			"}",
		]
	},
	"interpolate_polynomial": {
		"scope": "rust",
		"prefix": "interpolate_polynomial",
		"body": [
			"$0",
			"fn mul_add_row(mut row_a: [N; 11], row_b: [N; 11], f: N) -> [N; 11] {",
			"    for i in 0..11 {",
			"        row_a[i] += row_b[i] * f;",
			"    }",
			"    row_a",
			"}",
			"",
			"fn solve(mut matrix: [[N; 11]; 11], mut b: [N; 11]) -> [N; 11] {",
			"    for i in 0..11 {",
			"        let f = matrix[i][i];",
			"        for j in 0..11 {",
			"            matrix[i][j] /= f;",
			"        }",
			"        b[i] /= f;",
			"        for j in i + 1..11 {",
			"            b[j] -= b[i] * matrix[j][i];",
			"            matrix[j] = mul_add_row(matrix[j], matrix[i], -matrix[j][i]);",
			"        }",
			"    }",
			"    for i in (1..11).rev() {",
			"        for j in 0..i {",
			"            b[j] -= b[i] * matrix[j][i];",
			"            matrix[j] = mul_add_row(matrix[j], matrix[i], -matrix[j][i]);",
			"        }",
			"    }",
			"    b",
			"}",
			"",
			"fn eval(x: N, coef: &[N; 11]) -> N {",
			"    let mut res = N::ZERO;",
			"    for (i, c) in coef.iter().enumerate() {",
			"        res += x.pow(i) * *c;",
			"    }",
			"    res",
			"}",
		]
	},
	"lazy_segment_tree_beats": {
		"scope": "rust",
		"prefix": "lazy_segment_tree_beats",
		"body": [
			"$0",
			"pub struct LazySegmentTreeBeats {",
			"    pub n: usize,",
			"    pub tree: Vec<SegmentTreeType>,",
			"    lazy: Vec<Option<UpdateType>>,",
			"}",
			"impl LazySegmentTreeBeats {",
			"    pub fn new(initial: &[SegmentTreeType]) -> Self {",
			"        let n = input.len().next_power_of_two();",
			"        let mut tree = vec![DEFAULT_SEGMENT_TREE_TYPE; 2 * n - 1];",
			"        tree[n - 1..n - 1 + input.len()].clone_from_slice(input);",
			"        for i in (0..n - 1).rev() {",
			"            tree[i] = transform(&tree[2 * i + 1], &tree[2 * i + 2]);",
			"        }",
			"        Self {",
			"            tree,",
			"",
			"            lazy: vec![None; n - 1],",
			"            n,",
			"        }",
			"    }",
			"",
			"    /// Query the segment tree for the range [l, r) and update lazy stuff.",
			"    pub fn query(&mut self, l: usize, r: usize) -> Option<SegmentTreeType> {",
			"        self.query_rec(0, 0, self.n, l, r)",
			"    }",
			"",
			"    fn push_down(&mut self, i: usize) {",
			"        if let Some(v) = self.lazy[i].take() {",
			"            for j in 1..=2 {",
			"                let idx = (i << 1) + j;",
			"                if idx < self.tree.len() {",
			"                    self.tree[idx] = update(&self.tree[idx], &v, self.len_at(idx));",
			"                    self.add_lazy(idx, &v);",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"    fn query_rec(",
			"        &mut self,",
			"        i: usize,",
			"        il: usize,",
			"        ir: usize,",
			"        l: usize,",
			"        r: usize,",
			"    ) -> Option<SegmentTreeType> {",
			"        if ir <= l || r <= il {",
			"            return None;",
			"        }",
			"        if l <= il && ir <= r {",
			"            return Some(self.tree[i].clone());",
			"        }",
			"",
			"        self.push_down(i);",
			"",
			"        let m = (il + ir) >> 1;",
			"        let left = self.query_rec(2 * i + 1, il, m, l, r);",
			"        let right = self.query_rec(2 * i + 2, m, ir, l, r);",
			"        match (left, right) {",
			"            (Some(l), Some(r)) => Some(transform(&l, &r)),",
			"            (Some(l), None) => Some(l),",
			"            (None, Some(r)) => Some(r),",
			"            (None, None) => None,",
			"        }",
			"    }",
			"",
			"    fn add_lazy(&mut self, i: usize, v: &UpdateType) {",
			"        if i < self.lazy.len() {",
			"            if let Some(l) = self.lazy[i].take() {",
			"                self.lazy[i] = Some(todo!(\"aggregate\"));",
			"            } else {",
			"                self.lazy[i] = Some(v.clone());",
			"            }",
			"        }",
			"    }",
			"",
			"    /// Lazily update all values in [l; r) to v",
			"    pub fn update(&mut self, l: usize, r: usize, v: UpdateType) {",
			"        self.update_rec(0, 0, self.n, l, r, v);",
			"    }",
			"",
			"    fn update_rec(&mut self, i: usize, il: usize, ir: usize, l: usize, r: usize, v: UpdateType) {",
			"        if ir <= l || r <= il || todo!(\"breakCondition\") {",
			"            return;",
			"        }",
			"        if l <= il && ir <= r && todo!(\"tagCondition\") {",
			"            self.tree[i] = update(&self.tree[i], &v, self.len_at(i));",
			"            self.add_lazy(i, &v);",
			"            if i != 0 {",
			"                let mut i = i;",
			"                while i > 0 {",
			"                    i = (i - 1) >> 1;",
			"                    self.tree[i] = transform(&self.tree[(i << 1) + 1], &self.tree[(i << 1) + 2]);",
			"                }",
			"            }",
			"            return;",
			"        }",
			"",
			"        self.push_down(i);",
			"",
			"        let m = (il + ir) >> 1;",
			"        self.update_rec(2 * i + 1, il, m, l, r, v.clone());",
			"        self.update_rec(2 * i + 2, m, ir, l, r, v.clone());",
			"    }",
			"",
			"    fn len_at(&self, i: usize) -> usize {",
			"        self.n >> (i + 1).ilog2()",
			"    }",
			"}",
			"",
			"pub type SegmentTreeType = compile_error!(\"TagType\");",
			"pub type UpdateType = compile_error!(\"UpdateType\");",
			"const DEFAULT_SEGMENT_TREE_TYPE: SegmentTreeType = 0;",
			"",
			"pub fn transform(lhs: &SegmentTreeType, rhs: &SegmentTreeType) -> SegmentTreeType {",
			"    todo!()",
			"}",
			"pub fn update(old: &SegmentTreeType, update: &UpdateType, segment_len: usize) -> SegmentTreeType {",
			"    todo!()",
			"}",
		]
	},
	"lca": {
		"scope": "rust",
		"prefix": "lca",
		"body": [
			"$0",
			"pub struct Lca<const UP: usize = 20> {",
			"    up: Vec<[usize; UP]>,",
			"    tin: Vec<usize>,",
			"    tout: Vec<usize>,",
			"}",
			"impl<const UP: usize> Lca<UP> {",
			"    pub fn new(tree: &Vec<Vec<usize>>) -> Self {",
			"        let mut tin = vec![0; tree.len()];",
			"        let mut tout = vec![0; tree.len()];",
			"        let mut up = vec![[0; UP]; tree.len()];",
			"",
			"        fn dfs<const UP: usize>(",
			"            u: usize,",
			"            p: usize,",
			"            tree: &Vec<Vec<usize>>,",
			"            up: &mut Vec<[usize; UP]>,",
			"            tin: &mut Vec<usize>,",
			"            tout: &mut Vec<usize>,",
			"            t: &mut usize,",
			"        ) {",
			"            *t += 1;",
			"            up[u][0] = p;",
			"            tin[u] = *t;",
			"            for i in 1..up[u].len() {",
			"                up[u][i] = up[up[u][i - 1]][i - 1];",
			"            }",
			"",
			"            for v in &tree[u] {",
			"                if *v != p {",
			"                    dfs(*v, u, tree, up, tin, tout, t);",
			"                }",
			"            }",
			"",
			"            *t += 1;",
			"            tout[u] = *t;",
			"        }",
			"",
			"        dfs(0, 0, tree, &mut up, &mut tin, &mut tout, &mut 0);",
			"",
			"        Self { up, tin, tout }",
			"    }",
			"",
			"    pub fn is_anc(&self, u: usize, v: usize) -> bool {",
			"        self.tin[u] <= self.tin[v] && self.tout[v] <= self.tout[u]",
			"    }",
			"",
			"    /// Returns lca + parent[lca]",
			"    pub fn lca(&self, mut u: usize, v: usize) -> (usize, usize) {",
			"        if self.is_anc(u, v) {",
			"            return (u, self.up[u][0]);",
			"        }",
			"        if self.is_anc(v, u) {",
			"            return (v, self.up[v][0]);",
			"        }",
			"",
			"        for i in (0..self.up[0].len()).rev() {",
			"            if !self.is_anc(self.up[u][i], v) {",
			"                u = self.up[u][i];",
			"            }",
			"        }",
			"        (self.up[u][0], self.up[u][1])",
			"    }",
			"}",
		]
	},
	"maximum_weight_bipartite_matching": {
		"scope": "rust",
		"prefix": "maximum_weight_bipartite_matching",
		"body": [
			"$0",
			"// for minimal weighted matching simply invert the edge costs,",
			"// but note that an empty matching (e.g. if all edges negative) has a weight of `0`",
			"#[derive(Debug, Clone, PartialEq, Eq)]",
			"pub struct MaximumWeightBipartiteMatching {",
			"    graph: Vec<Vec<(usize, isize)>>,",
			"    alen: usize,",
			"}",
			"impl MaximumWeightBipartiteMatching {",
			"    pub fn new(mut a: Vec<Vec<(usize, isize)>>, blen: usize) -> Self {",
			"        for v in &mut a {",
			"            v.sort_unstable();",
			"        }",
			"        let alen = a.len();",
			"        let mut b = vec![vec![]; blen];",
			"        for (u, connected_to) in a.iter_mut().enumerate() {",
			"            for (v, c) in connected_to.iter_mut() {",
			"                b[*v].push((u + 1, isize::MAX));",
			"                *v += alen + 1;",
			"                *c = c.saturating_neg();",
			"            }",
			"            connected_to.insert(0, (0, isize::MAX));",
			"        }",
			"        for u in 0..blen {",
			"            b[u].push((alen + blen + 1, 0));",
			"        }",
			"        a.insert(0, (1..=alen).map(|x| (x, 0)).cv());",
			"        a.extend(b);",
			"        a.push((alen + 1..alen + 1 + blen).map(|x| (x, isize::MAX)).cv());",
			"        Self { graph: a, alen }",
			"    }",
			"",
			"    pub fn calculate(mut self) -> Vec<(usize, usize, isize)> {",
			"        let mut matching = HashSet::new();",
			"        while let Some(augment) = self.bellman_ford() {",
			"            for i in 1..augment.len() {",
			"                let (u, v) = (augment[i - 1], augment[i]);",
			"                let vi = self.graph[u].binary_search_by_key(&v, |x| x.0).unwrap();",
			"                let ui = self.graph[v].binary_search_by_key(&u, |x| x.0).unwrap();",
			"                self.graph[v][ui].1 = -self.graph[u][vi].1;",
			"                self.graph[u][vi].1 = isize::MAX;",
			"                if u < v {",
			"                    assert!(matching.insert((u, v, -self.graph[v][ui].1)));",
			"                } else {",
			"                    assert!(matching.remove(&(v, u, self.graph[v][ui].1)));",
			"                }",
			"            }",
			"        }",
			"        matching",
			"            .into_iter()",
			"            .filter(|&(u, v, _)| u != 0 && v != self.graph.len() - 1)",
			"            .map(|(u, v, c)| (u - 1, v - 1 - self.alen, c.saturating_neg()))",
			"            .cv()",
			"    }",
			"",
			"    fn bellman_ford(&self) -> Option<Vec<usize>> {",
			"        let mut dist = vec![isize::MAX; self.graph.len()];",
			"        dist[0] = 0;",
			"        let mut parent = vec![usize::MAX; self.graph.len()];",
			"",
			"        for j in 0..dist.len() {",
			"            let mut changed = false;",
			"            for u in 0..self.graph.len() {",
			"                if dist[u] == isize::MAX {",
			"                    continue;",
			"                }",
			"                for (v, c) in &self.graph[u] {",
			"                    if *c != isize::MAX {",
			"                        if dist[u] + c < dist[*v] {",
			"                            dist[*v] = dist[u] + c;",
			"                            parent[*v] = u;",
			"                            changed = true;",
			"                        }",
			"                    }",
			"                }",
			"            }",
			"            if !changed {",
			"                break;",
			"            }",
			"            if j + 1 == dist.len() {",
			"                panic!(\"Negative cycle!\");",
			"            }",
			"        }",
			"        if dist.l() >= 0 {",
			"            return None;",
			"        }",
			"        let mut cur = dist.len() - 1;",
			"        let mut path = vec![cur];",
			"        while parent[cur] != usize::MAX {",
			"            path.push(parent[cur]);",
			"            cur = parent[cur];",
			"        }",
			"        path.reverse();",
			"        Some(path)",
			"    }",
			"}",
		]
	},
	"modint": {
		"scope": "rust",
		"prefix": "modint",
		"body": [
			"$0",
			"// type N = Mod<998_244_353>;",
			"// type N = Mod<1_000_000_007>;",
			"",
			"// type N = Mod<156859239850691603>; // randomize hacks possible",
			"// const K: N = N::new(3414519959);",
			"",
			"use std::ops::*;",
			"",
			"#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default, Debug)]",
			"pub struct Mod<const MOD: usize>(pub usize);",
			"#[allow(unused)]",
			"impl<const MOD: usize> Mod<MOD> {",
			"    const ZERO: Self = Self::new(0);",
			"    const NEG_ONE: Self = Self::newi(-1);",
			"    const ONE: Self = Self::new(1);",
			"    const TWO: Self = Self::new(2);",
			"",
			"    pub const fn newi(x: isize) -> Self {",
			"        Self::new(((x % MOD as isize) + MOD as isize) as usize)",
			"    }",
			"",
			"    pub const fn new(x: usize) -> Self {",
			"        Self(x % MOD)",
			"    }",
			"    pub const fn pow(self, mut e: usize) -> Self {",
			"        let mut res = Self(1);",
			"        let mut cur = self;",
			"        while e > 0 {",
			"            if e & 1 == 1 {",
			"                res = Self(((res.0 as u128 * cur.0 as u128) % MOD as u128) as usize);",
			"            }",
			"            cur = Self(((cur.0 as u128 * cur.0 as u128) % MOD as u128) as usize);",
			"            e >>= 1;",
			"        }",
			"        res",
			"    }",
			"    pub const fn inv(self) -> Self {",
			"        self.pow(MOD - 2)",
			"    }",
			"}",
			"impl<const MOD: usize> std::iter::Sum for Mod<MOD> {",
			"    fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {",
			"        iter.fold(Self::ZERO, |a, b| a + b)",
			"    }",
			"}",
			"impl<const MOD: usize> std::iter::Product for Mod<MOD> {",
			"    fn product<I: Iterator<Item = Self>>(iter: I) -> Self {",
			"        iter.fold(Self::ONE, |a, b| a * b)",
			"    }",
			"}",
			"impl<const MOD: usize> std::fmt::Display for Mod<MOD> {",
			"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
			"        f.pad_integral(true, \"\", &self.0.to_string())",
			"    }",
			"}",
			"impl<const MOD: usize> AsRef<usize> for Mod<MOD> {",
			"    fn as_ref(&self) -> &usize {",
			"        &self.0",
			"    }",
			"}",
			"impl<const MOD: usize> AsMut<usize> for Mod<MOD> {",
			"    fn as_mut(&mut self) -> &mut usize {",
			"        &mut self.0",
			"    }",
			"}",
			"impl<const MOD: usize> Add for Mod<MOD> {",
			"    type Output = Self;",
			"    fn add(self, rhs: Self) -> Self {",
			"        Self((self.0 + rhs.0) % MOD)",
			"    }",
			"}",
			"impl<const MOD: usize> Add<usize> for Mod<MOD> {",
			"    type Output = Self;",
			"    fn add(self, rhs: usize) -> Self {",
			"        Self((self.0 + rhs) % MOD)",
			"    }",
			"}",
			"impl<const MOD: usize> Sub for Mod<MOD> {",
			"    type Output = Self;",
			"    fn sub(self, rhs: Self) -> Self {",
			"        Self((self.0 + MOD - rhs.0) % MOD)",
			"    }",
			"}",
			"impl<const MOD: usize> Sub<usize> for Mod<MOD> {",
			"    type Output = Self;",
			"    fn sub(self, rhs: usize) -> Self {",
			"        Self((self.0 + MOD - rhs) % MOD)",
			"    }",
			"}",
			"impl<const MOD: usize> Mul for Mod<MOD> {",
			"    type Output = Self;",
			"    fn mul(self, rhs: Self) -> Self {",
			"        if MOD < u32::MAX as usize {",
			"            Self((self.0 * rhs.0) % MOD)",
			"        } else {",
			"            Self(((self.0 as u128 * rhs.0 as u128) % MOD as u128) as usize)",
			"        }",
			"    }",
			"}",
			"impl<const MOD: usize> Mul<usize> for Mod<MOD> {",
			"    type Output = Self;",
			"    fn mul(self, rhs: usize) -> Self {",
			"        if MOD < u32::MAX as usize {",
			"            Self((self.0 * rhs) % MOD)",
			"        } else {",
			"            Self(((self.0 as u128 * rhs as u128) % MOD as u128) as usize)",
			"        }",
			"    }",
			"}",
			"impl<const MOD: usize> Div for Mod<MOD> {",
			"    type Output = Self;",
			"    fn div(self, rhs: Self) -> Self {",
			"        self * rhs.inv()",
			"    }",
			"}",
			"impl<const MOD: usize> Div<usize> for Mod<MOD> {",
			"    type Output = Self;",
			"    fn div(self, rhs: usize) -> Self {",
			"        self * Mod::new(rhs).inv()",
			"    }",
			"}",
			"impl<const MOD: usize> Neg for Mod<MOD> {",
			"    type Output = Self;",
			"",
			"    fn neg(self) -> Self::Output {",
			"        Self::new(MOD - self.0)",
			"    }",
			"}",
			"impl<const MOD: usize> Neg for &Mod<MOD> {",
			"    type Output = Mod<MOD>;",
			"",
			"    fn neg(self) -> Self::Output {",
			"        Self::Output::new(MOD - self.0)",
			"    }",
			"}",
			"macro_rules! impl_mod_rest {",
			"    (\\$(\\$trait:ident::\\$fn:ident:\\$trait_assign:ident::\\$fn_assign:ident;)*) => {",
			"        \\$(",
			"            impl<const MOD: usize> \\$trait<&Mod<MOD>> for Mod<MOD> {",
			"                type Output = Mod<MOD>;",
			"",
			"                fn \\$fn(self, rhs: &Mod<MOD>) -> Self::Output {",
			"                    \\$trait::\\$fn(self, *rhs)",
			"                }",
			"            }",
			"            impl<const MOD: usize> \\$trait<&Mod<MOD>> for &Mod<MOD> {",
			"                type Output = Mod<MOD>;",
			"",
			"                fn \\$fn(self, rhs: &Mod<MOD>) -> Self::Output {",
			"                    \\$trait::\\$fn(*self, *rhs)",
			"                }",
			"            }",
			"            impl<const MOD: usize> \\$trait<Mod<MOD>> for &Mod<MOD> {",
			"                type Output = Mod<MOD>;",
			"",
			"                fn \\$fn(self, rhs: Mod<MOD>) -> Self::Output {",
			"                    \\$trait::\\$fn(*self, rhs)",
			"                }",
			"            }",
			"            impl<const MOD: usize> \\$trait<&usize> for Mod<MOD> {",
			"                type Output = Mod<MOD>;",
			"",
			"                fn \\$fn(self, rhs: &usize) -> Self::Output {",
			"                    \\$trait::\\$fn(self, *rhs)",
			"                }",
			"            }",
			"            impl<const MOD: usize> \\$trait<&usize> for &Mod<MOD> {",
			"                type Output = Mod<MOD>;",
			"",
			"                fn \\$fn(self, rhs: &usize) -> Self::Output {",
			"                    \\$trait::\\$fn(*self, *rhs)",
			"                }",
			"            }",
			"            impl<const MOD: usize> \\$trait<usize> for &Mod<MOD> {",
			"                type Output = Mod<MOD>;",
			"",
			"                fn \\$fn(self, rhs: usize) -> Self::Output {",
			"                    \\$trait::\\$fn(*self, rhs)",
			"                }",
			"            }",
			"            impl<const MOD: usize> \\$trait_assign for Mod<MOD> {",
			"                fn \\$fn_assign(&mut self, rhs: Mod<MOD>) {",
			"                    *self = \\$trait::\\$fn(*self, rhs);",
			"                }",
			"            }",
			"            impl<const MOD: usize> \\$trait_assign<&Mod<MOD>> for Mod<MOD> {",
			"                fn \\$fn_assign(&mut self, rhs: &Mod<MOD>) {",
			"                    *self = \\$trait::\\$fn(*self, rhs);",
			"                }",
			"            }",
			"            impl<const MOD: usize> \\$trait_assign<usize> for Mod<MOD> {",
			"                fn \\$fn_assign(&mut self, rhs: usize) {",
			"                    *self = \\$trait::\\$fn(*self, rhs);",
			"                }",
			"            }",
			"            impl<const MOD: usize> \\$trait_assign<&usize> for Mod<MOD> {",
			"                fn \\$fn_assign(&mut self, rhs: &usize) {",
			"                    *self = \\$trait::\\$fn(*self, rhs);",
			"                }",
			"            }",
			"        )*",
			"    };",
			"}",
			"impl_mod_rest! {",
			"    Add::add:AddAssign::add_assign;",
			"    Sub::sub:SubAssign::sub_assign;",
			"    Mul::mul:MulAssign::mul_assign;",
			"    Div::div:DivAssign::div_assign;",
			"}",
		]
	},
	"ntt": {
		"scope": "rust",
		"prefix": "ntt",
		"body": [
			"$0",
			"// require mod_int",
			"",
			"// to find primitive roots: https://www.wolframalpha.com/input/?i=PrimitiveRoots%5B%5B%2F%2Fnumber%3A998244353%2F%2F%5D%5D",
			"const MOD: usize = 998244353; // 2^23 * 7 * 17 + 1",
			"const C: usize = 119;",
			"const ROOT_PW: usize = 1 << 23;",
			"const G: M = M::new(3);",
			"const ROOT: M = G.pow(C);",
			"const ROOT_1: M = ROOT.inv();",
			"type M = Mod<MOD>;",
			"",
			"// from https://cp-algorithms.com/algebra/fft.html#number-theoretic-transform",
			"pub fn fft(a: &mut Vec<M>, invert: bool) {",
			"    let n = a.len();",
			"",
			"    let mut j = 0;",
			"    for i in 1..n {",
			"        let mut bit = n >> 1;",
			"        while j & bit != 0 {",
			"            j ^= bit;",
			"            bit >>= 1;",
			"        }",
			"        j ^= bit;",
			"        if i < j {",
			"            a.swap(i, j);",
			"        }",
			"    }",
			"",
			"    let mut len = 2;",
			"    while len <= n {",
			"        let mut wlen = if invert { ROOT_1 } else { ROOT };",
			"        let mut i = len;",
			"        while i < ROOT_PW {",
			"            wlen *= wlen;",
			"            i <<= 1;",
			"        }",
			"        for i in (0..n).step_by(len) {",
			"            let mut w = M::ONE;",
			"            for j in 0..len / 2 {",
			"                let u = a[i + j];",
			"                let v = a[i + j + len / 2] * w;",
			"                a[i + j] = u + v;",
			"                a[i + j + len / 2] = u - v;",
			"                w *= wlen;",
			"            }",
			"        }",
			"",
			"        len <<= 1;",
			"    }",
			"",
			"    if invert {",
			"        let n_1 = M::new(n).inv();",
			"        for x in a {",
			"            *x *= n_1;",
			"        }",
			"    }",
			"}",
			"",
			"pub fn multiply(a: &Vec<M>, b: &Vec<M>) -> Vec<M> {",
			"    let mut fa = a.clone();",
			"    let mut fb = b.clone();",
			"    let n = (a.len() + b.len()).next_power_of_two();",
			"",
			"    fa.resize(n, M::ZERO);",
			"    fb.resize(n, M::ZERO);",
			"",
			"    fft(&mut fa, false);",
			"    fft(&mut fb, false);",
			"    for (fai, fbi) in fa.iter_mut().zip(fb) {",
			"        *fai *= fbi;",
			"    }",
			"    fft(&mut fa, true);",
			"",
			"    fa",
			"}",
		]
	},
	"pattern_matching_wildcards": {
		"scope": "rust",
		"prefix": "pattern_matching_wildcards",
		"body": [
			"$0",
			"// requires ntt, modint",
			"",
			"/// `a`, `b` lowercase latin character or wildcard",
			"/// `a`, `b` lowercase latin character or wildcard",
			"pub fn wildcard_match(a: &[char], b: &[char], wildcard: char) -> Vec<bool> {",
			"    let mut rng = Rng::new();",
			"    let enc = (0..26)",
			"        .map(|_| M::new(rng.next() as U))",
			"        .map(|x| if x.0 < 5 { x + 5 } else { x })",
			"        .map(|x| (x, M::ONE / x))",
			"        .cv();",
			"    let ap = a",
			"        .iter()",
			"        .copied()",
			"        .map(|c| {",
			"            if c == wildcard {",
			"                M::ZERO",
			"            } else {",
			"                enc[c as usize - b'a' as usize].0",
			"            }",
			"        })",
			"        .cv();",
			"    let bp = b",
			"        .iter()",
			"        .copied()",
			"        .map(|c| {",
			"            if c == wildcard {",
			"                M::ZERO",
			"            } else {",
			"                enc[c as usize - b'a' as usize].1",
			"            }",
			"        })",
			"        .rev()",
			"        .cv();",
			"    let duplicates = multiply(",
			"        &a.iter()",
			"            .copied()",
			"            .map(|c| if c == wildcard { M::ONE } else { M::ZERO })",
			"            .cv(),",
			"        &b.iter()",
			"            .copied()",
			"            .map(|c| if c == wildcard { M::ONE } else { M::ZERO })",
			"            .rev()",
			"            .cv(),",
			"    );",
			"    let result = multiply(&ap, &bp).into_iter().map(|x| x.0).cv();",
			"    let mut prefix_wildcard = vec![0];",
			"    for c in a.iter().copied() {",
			"        prefix_wildcard.push(prefix_wildcard.l() + if c == wildcard { 1 } else { 0 });",
			"    }",
			"    let b_wildcard = b.iter().copied().filter(|c| c == &wildcard).count();",
			"    let mut out = Vec::new();",
			"    for i in b.len() - 1..a.len() {",
			"        let wildcards = b_wildcard + (prefix_wildcard[i + 1] - prefix_wildcard[i - (b.len() - 1)]);",
			"        out.push(",
			"            result[i] as I",
			"                == b.len() as I + duplicates.get(i).map(|x| x.0).unwrap_or(0) as I - wildcards as I,",
			"        );",
			"    }",
			"    out",
			"}",
		]
	},
	"persistent_segment_tree": {
		"scope": "rust",
		"prefix": "persistent_segment_tree",
		"body": [
			"$0",
			"pub struct PersistentSegmentTree {",
			"    roots: Vec<usize>,",
			"    nodes: Vec<(usize, usize, SegmentTreeType)>,",
			"    n: usize,",
			"}",
			"impl PersistentSegmentTree {",
			"    pub fn build(initial_values: &[SegmentTreeType]) -> Self {",
			"        let n = initial_values.len();",
			"        let mut nodes = vec![];",
			"        let root = Self::build_recursive(0, n, initial_values, &mut nodes);",
			"        let roots = vec![root];",
			"        Self { roots, nodes, n }",
			"    }",
			"    fn build_recursive(",
			"        i: usize,",
			"        j: usize,",
			"        initial_values: &[SegmentTreeType],",
			"        nodes: &mut Vec<(usize, usize, SegmentTreeType)>,",
			"    ) -> usize {",
			"        if j - i == 1 {",
			"            let node = nodes.len();",
			"            nodes.push((usize::MAX, usize::MAX, initial_values[i].clone()));",
			"            node",
			"        } else {",
			"            let m = (i + j) / 2;",
			"            let left = Self::build_recursive(i, m, initial_values, nodes);",
			"            let right = Self::build_recursive(m, j, initial_values, nodes);",
			"            let node = nodes.len();",
			"            nodes.push((left, right, transform(&nodes[left].2, &nodes[right].2)));",
			"            node",
			"        }",
			"    }",
			"",
			"    /// Returns the \"pointer\" to the new root",
			"    pub fn update(&mut self, root: usize, i: usize, value: UpdateType) -> usize {",
			"        let new_root = self.update_recursive(self.roots[root], 0, self.n, i, value);",
			"        self.roots.push(new_root);",
			"        self.roots.len() - 1",
			"    }",
			"",
			"    fn update_recursive(",
			"        &mut self,",
			"        node: usize,",
			"        left: usize,",
			"        right: usize,",
			"        index: usize,",
			"        value: UpdateType,",
			"    ) -> usize {",
			"        if right - left == 1 {",
			"            let new_node = self.nodes.len();",
			"            self.nodes",
			"                .push((usize::MAX, usize::MAX, update(&self.nodes[node].2, &value)));",
			"            new_node",
			"        } else {",
			"            let m = (left + right) / 2;",
			"            let (l, r, _) = &self.nodes[node];",
			"            let mut new_left = *l;",
			"            let mut new_right = *r;",
			"            if index < m {",
			"                new_left = self.update_recursive(*l, left, m, index, value);",
			"            } else {",
			"                new_right = self.update_recursive(*r, m, right, index, value);",
			"            }",
			"            let new_value = transform(&self.nodes[new_left].2, &self.nodes[new_right].2);",
			"            let new_node = self.nodes.len();",
			"            self.nodes.push((new_left, new_right, new_value));",
			"            new_node",
			"        }",
			"    }",
			"    pub fn query(&self, root: usize, i: usize, j: usize) -> SegmentTreeType {",
			"        self.query_recursive(self.roots[root], 0, self.n, i, j)",
			"    }",
			"    fn query_recursive(",
			"        &self,",
			"        node: usize,",
			"        left: usize,",
			"        right: usize,",
			"        i: usize,",
			"        j: usize,",
			"    ) -> SegmentTreeType {",
			"        if i <= left && right <= j {",
			"            self.nodes[node].2.clone()",
			"        } else {",
			"            let m = (left + right) / 2;",
			"            let (left_child, right_child, _) = self.nodes[node];",
			"            if j <= m {",
			"                self.query_recursive(left_child, left, m, i, j)",
			"            } else if m <= i {",
			"                self.query_recursive(right_child, m, right, i, j)",
			"            } else {",
			"                let left_value = self.query_recursive(left_child, left, m, i, j);",
			"                let right_value = self.query_recursive(right_child, m, right, i, j);",
			"                transform(&left_value, &right_value)",
			"            }",
			"        }",
			"    }",
			"}",
			"",
			"pub type SegmentTreeType = compile_error!(\"SegmentTreeType\");",
			"pub type UpdateType = compile_error!(\"UpdateType\");",
			"",
			"pub fn transform(lhs: &SegmentTreeType, rhs: &SegmentTreeType) -> SegmentTreeType {",
			"    todo!()",
			"}",
			"pub fn update(old: &SegmentTreeType, update: &UpdateType) -> SegmentTreeType {",
			"    todo!()",
			"}",
		]
	},
	"polyprod": {
		"scope": "rust",
		"prefix": "polyprod",
		"body": [
			"$0",
			"pub fn polyprod(p: Vec<Vec<isize>>, m: isize) -> Vec<isize> {",
			"    let mut polynomials = std::collections::BinaryHeap::new();",
			"    for p in p {",
			"        polynomials.push(Comparator(p));",
			"    }",
			"    while polynomials.len() > 1 {",
			"        let x = Comparator(",
			"            multiply(&polynomials.pop().unwrap().0, &polynomials.pop().unwrap().0)",
			"                .into_iter()",
			"                .map(|x| x % m)",
			"                .cv(),",
			"        );",
			"        polynomials.push(x);",
			"    }",
			"    polynomials.pop().unwrap().0",
			"}",
			"",
			"#[derive(Debug)]",
			"struct Comparator(Vec<I>);",
			"impl PartialEq for Comparator {",
			"    fn eq(&self, other: &Self) -> bool {",
			"        self.cmp(other).is_eq()",
			"    }",
			"}",
			"impl Eq for Comparator {}",
			"impl Ord for Comparator {",
			"    fn cmp(&self, other: &Self) -> std::cmp::Ordering {",
			"        self.0.len().cmp(&other.0.len()).reverse()",
			"    }",
			"}",
			"impl PartialOrd for Comparator {",
			"    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {",
			"        Some(self.cmp(other))",
			"    }",
			"}",
		]
	},
	"rope": {
		"scope": "rust",
		"prefix": "rope",
		"body": [
			"$0",
			"pub struct Rope {",
			"    pub tree: Vec<usize>,",
			"}",
			"impl Rope {",
			"    pub fn new(input: &[usize]) -> Self {",
			"        let n = input.len().next_power_of_two();",
			"        let mut tree = Vec::with_capacity(2 * n - 1);",
			"        unsafe {",
			"            tree.set_len(2 * n - 1);",
			"        }",
			"        tree[n - 1..n - 1 + input.len()].clone_from_slice(input);",
			"        for i in n - 1 + input.len()..2 * n - 1 {",
			"            tree[i] = 0;",
			"        }",
			"        for i in (0..n - 1).rev() {",
			"            tree[i] = tree[2 * i + 1] + tree[2 * i + 2];",
			"        }",
			"        Self { tree }",
			"    }",
			"",
			"    /// Query the segment tree for the range [l, r).",
			"    pub fn query(&self, v: usize) -> Option<usize> {",
			"        self.query_rec(0, 0, (self.tree.len() + 1) >> 1, v)",
			"    }",
			"",
			"    fn query_rec(&self, i: usize, il: usize, ir: usize, v: usize) -> Option<usize> {",
			"        if v == 1 && il + 1 == ir {",
			"            return Some(i - ((self.tree.len() + 1) / 2 - 1));",
			"        }",
			"        let m = (il + ir) >> 1;",
			"        if self.tree[2 * i + 1] < v {",
			"            self.query_rec(2 * i + 2, m, ir, v - self.tree[2 * i + 1])",
			"        } else {",
			"            self.query_rec(2 * i + 1, il, m, v)",
			"        }",
			"    }",
			"",
			"    pub fn update(&mut self, i: usize) {",
			"        let n = (self.tree.len() + 1) / 2;",
			"        let mut i = i + n - 1;",
			"        self.tree[i] = 0;",
			"        while i > 0 {",
			"            i = (i - 1) / 2;",
			"            self.tree[i] = self.tree[2 * i + 1] + self.tree[2 * i + 2];",
			"        }",
			"    }",
			"}",
		]
	},
	"segment_tree": {
		"scope": "rust",
		"prefix": "segment_tree",
		"body": [
			"$0",
			"pub struct SegmentTree {",
			"    pub tree: Vec<SegmentTreeType>,",
			"}",
			"impl SegmentTree {",
			"    pub fn new(input: &[SegmentTreeType]) -> Self {",
			"        let n = input.len().next_power_of_two();",
			"        let mut tree = vec![DEFAULT_SEGMENT_TREE_TYPE; 2 * n - 1];",
			"        tree[n - 1..n - 1 + input.len()].clone_from_slice(input);",
			"        for i in (0..n - 1).rev() {",
			"            tree[i] = transform(&tree[2 * i + 1], &tree[2 * i + 2]);",
			"        }",
			"        Self { tree }",
			"    }",
			"",
			"    /// Query the segment tree for the range [l, r).",
			"    pub fn query(&self, l: usize, r: usize) -> Option<SegmentTreeType> {",
			"        self.query_rec(0, 0, (self.tree.len() + 1) >> 1, l, r)",
			"    }",
			"",
			"    fn query_rec(",
			"        &self,",
			"        i: usize,",
			"        il: usize,",
			"        ir: usize,",
			"        l: usize,",
			"        r: usize,",
			"    ) -> Option<SegmentTreeType> {",
			"        if ir <= l || r <= il {",
			"            return None;",
			"        }",
			"        if l <= il && ir <= r {",
			"            return Some(self.tree[i].clone());",
			"        }",
			"        let m = (il + ir) >> 1;",
			"        let left = self.query_rec(2 * i + 1, il, m, l, r);",
			"        let right = self.query_rec(2 * i + 2, m, ir, l, r);",
			"        match (left, right) {",
			"            (Some(left), Some(right)) => Some(transform(&left, &right)),",
			"            (Some(left), None) => Some(left),",
			"            (None, Some(right)) => Some(right),",
			"            (None, None) => None,",
			"        }",
			"    }",
			"",
			"    pub fn update(&mut self, i: usize, v: SegmentTreeType) {",
			"        let n = (self.tree.len() + 1) / 2;",
			"        let mut i = i + n - 1;",
			"        self.tree[i] = v;",
			"        while i > 0 {",
			"            i = (i - 1) / 2;",
			"            self.tree[i] = transform(&self.tree[2 * i + 1], &self.tree[2 * i + 2]);",
			"        }",
			"    }",
			"}",
			"",
			"pub type SegmentTreeType = compile_error!(\"SegmenTreeType\");",
			"const DEFAULT_SEGMENT_TREE_TYPE: SegmentTreeType = 0;",
			"",
			"pub fn transform(lhs: &SegmentTreeType, rhs: &SegmentTreeType) -> SegmentTreeType {",
			"    todo!()",
			"}",
		]
	},
	"sieve": {
		"scope": "rust",
		"prefix": "sieve",
		"body": [
			"$0",
			"/// lowprime sieve: linear, sieve, primes, divisor",
			"/// computes lp[i] where lp[i] is the lowest prime divisor of i and pr, where pr[i] is the i-th prime number",
			"/// C: O(n), R: nothing",
			"///",
			"/// from: https://github.com/TecTrixer/cp-template/blob/main/template.rs",
			"fn lp(n: U) {",
			"    let mut lp = vec![0; n + 1];",
			"    let mut pr = vec![];",
			"    for i in 2..=n {",
			"        if lp[i] == 0 {",
			"            lp[i] = i;",
			"            pr.push(i);",
			"        }",
			"        let mut j = 0;",
			"        while i * pr[j] <= n {",
			"            lp[i * pr[j]] = pr[j];",
			"            if pr[j] == lp[i] {",
			"                break;",
			"            }",
			"            j += 1;",
			"        }",
			"    }",
			"}",
		]
	},
	"sqrt": {
		"scope": "rust",
		"prefix": "sqrt",
		"body": [
			"$0",
			"/// Tries to calculate the square root of x, `None` if `x` is not a perfect square",
			"pub fn sqrt(x: u128) -> Option<u128> {",
			"    let mut l = 0;",
			"    let mut r = x + 1;",
			"    while l <= r {",
			"        let mid = (l + r) >> 1;",
			"        match (mid.saturating_mul(mid)).cmp(&x) {",
			"            Ordering::Equal => return Some(mid),",
			"            Ordering::Greater => r = mid - 1,",
			"            Ordering::Less => l = mid + 1,",
			"        }",
			"    }",
			"    None",
			"}",
		]
	},
	"template": {
		"scope": "rust",
		"prefix": "template",
		"body": [
			"fn main() {",
			"    let _io = Io::new();",
			"    for _ in 0..r!(U) {",
			"        // let (n, q) = r!(U, U);",
			"        // let n = r!(U);",
			"        // let a = (0..n).map(|_| r!(U)).cv();",
			"        $0",
			"    }",
			"}",
			"",
			"pub fn lcm(u: U, v: U) -> U {",
			"    u * v / gcd(u, v)",
			"}",
			"// gcd from wiki: https://en.wikipedia.org/wiki/Binary_GCD_algorithm",
			"pub fn gcd(mut u: U, mut v: U) -> U {",
			"    if u == 0 {",
			"        return v;",
			"    } else if v == 0 {",
			"        return u;",
			"    }",
			"",
			"    let i = u.trailing_zeros();",
			"    u >>= i;",
			"    let j = v.trailing_zeros();",
			"    v >>= j;",
			"    let k = std::cmp::min(i, j);",
			"    loop {",
			"        if u > v {",
			"            std::mem::swap(&mut u, &mut v);",
			"        }",
			"        v -= u;",
			"        if v == 0 {",
			"            return u << k;",
			"        }",
			"        v >>= v.trailing_zeros();",
			"    }",
			"}",
			"pub struct Rng {",
			"    seed: u32,",
			"}",
			"impl Rng {",
			"    pub fn new() -> Self {",
			"        Self {",
			"            seed: std::time::SystemTime::now()",
			"                .duration_since(std::time::SystemTime::UNIX_EPOCH)",
			"                .unwrap()",
			"                .subsec_nanos(),",
			"        }",
			"    }",
			"",
			"    pub fn next(&mut self) -> u32 {",
			"        self.seed ^= self.seed << 13;",
			"        self.seed ^= self.seed >> 17;",
			"        self.seed ^= self.seed << 5;",
			"        self.seed",
			"    }",
			"}",
			"pub trait IterExt<T> {",
			"    fn n(&mut self) -> T;",
			"    fn cv(self) -> Vec<T>;",
			"}",
			"impl<T, I: Iterator<Item = T>> IterExt<T> for I {",
			"    fn cv(self) -> Vec<T> {",
			"        self.collect()",
			"    }",
			"",
			"    fn n(&mut self) -> T {",
			"        self.next().unwrap()",
			"    }",
			"}",
			"pub trait IterExt2<T: PartialOrd> {",
			"    fn mn(self) -> T;",
			"    fn mx(self) -> T;",
			"}",
			"",
			"impl<T: PartialOrd, I: IntoIterator<Item = T>> IterExt2<T> for I {",
			"    fn mn(self) -> T {",
			"        self.into_iter()",
			"            .min_by(|a, b| a.partial_cmp(b).unwrap())",
			"            .unwrap()",
			"    }",
			"    fn mx(self) -> T {",
			"        self.into_iter()",
			"            .max_by(|a, b| a.partial_cmp(b).unwrap())",
			"            .unwrap()",
			"    }",
			"}",
			"pub trait IterExt3<T: ToString> {",
			"    fn to_string(self, sep: &str) -> String;",
			"}",
			"impl<T: ToString, I: IntoIterator<Item = T>> IterExt3<T> for I {",
			"    fn to_string(self, sep: &str) -> String {",
			"        self.into_iter().map(|x| x.to_string()).cv().join(sep)",
			"    }",
			"}",
			"pub trait IterExt4<T: Clone> {",
			"    fn l(&self) -> T;",
			"}",
			"impl<T: Clone> IterExt4<T> for Vec<T> {",
			"    fn l(&self) -> T {",
			"        self[self.len() - 1].clone()",
			"    }",
			"}",
			"impl<T: Clone> IterExt4<T> for &[T] {",
			"    fn l(&self) -> T {",
			"        self[self.len() - 1].clone()",
			"    }",
			"}",
			"impl<T: Clone> IterExt4<T> for &mut [T] {",
			"    fn l(&self) -> T {",
			"        self[self.len() - 1].clone()",
			"    }",
			"}",
			"",
			"// from https://github.com/TecTrixer/cp-template/blob/main/temp.rs",
			"use lib::*;",
			"#[rustfmt::skip]",
			"mod lib {",
			"#![allow(dead_code, unused_imports)]",
			"pub use std::collections::{HashMap, HashSet};",
			"use std::{",
			"fmt::Display,",
			"io::{",
			"    stdin, stdout, BufRead, BufReader, BufWriter, Cursor, Error, ErrorKind, Read, Stdin,",
			"    Stdout, Write,",
			"},",
			"str::{from_utf8_unchecked, FromStr}, ops::Deref,",
			"};",
			"pub static mut IO: Option<IoInner<Stdin, Stdout>> = None;",
			"pub type U = usize;",
			"pub type I = isize;",
			"pub type F = f64;",
			"pub type B = u8;",
			"fn is_skip_char(&b: &u8) -> bool {",
			"    b == b' ' || b == b'\\n' || b == b'\\r' || b == b'\\t' || b == b','",
			"}",
			"pub struct IoInner<R, W>",
			"where",
			"    R: Read,",
			"    W: Write,",
			"{",
			"    input: BufReader<R>,",
			"    output: BufWriter<W>,",
			"}",
			"pub struct Io;",
			"impl std::ops::DerefMut for Io {",
			"    fn deref_mut(&mut self) -> &mut Self::Target {",
			"            unsafe { IO.as_mut().unwrap_unchecked() }",
			"    }",
			"}",
			"impl Deref for Io {",
			"    type Target = IoInner<Stdin, Stdout>;",
			"    fn deref(&self) -> &Self::Target {",
			"            unsafe { IO.as_mut().unwrap_unchecked() }",
			"    }",
			"}",
			"impl Io {",
			"pub fn new() -> Self {",
			"    unsafe {",
			"        IO = Some(IoInner::new());",
			"    }",
			"    Self",
			"}",
			"}",
			"impl IoInner<&[u8], Stdout> {",
			"#[allow(clippy::should_implement_trait)]",
			"pub fn from_str(input: &str) -> IoInner<&[u8], Stdout> {",
			"    IoInner {",
			"        input: BufReader::new(input.as_bytes()),",
			"        output: BufWriter::new(stdout()),",
			"    }",
			"}",
			"pub fn from_string(input: String) -> IoInner<Cursor<String>, Stdout> {",
			"    IoInner {",
			"        input: BufReader::new(Cursor::new(input)),",
			"        output: BufWriter::new(stdout()),",
			"    }",
			"}",
			"}",
			"impl IoInner<Stdin, Stdout> {",
			"pub fn new() -> IoInner<Stdin, Stdout> {",
			"    IoInner {",
			"        input: BufReader::new(stdin()),",
			"        output: BufWriter::new(stdout()),",
			"    }",
			"}",
			"}",
			"impl Drop for Io {",
			"fn drop(&mut self) {",
			"    self.flush();",
			"}",
			"}",
			"impl<R: Read, W: Write> IoInner<R, W> {",
			"pub fn with_reader_and_writer(reader: R, writer: W) -> IoInner<R, W> {",
			"    IoInner {",
			"        input: BufReader::new(reader),",
			"        output: BufWriter::new(writer),",
			"    }",
			"}",
			"pub fn r<T: FromStr>(&mut self) -> T {",
			"    let buf = self",
			"        .input",
			"        .by_ref()",
			"        .bytes()",
			"        .map(|x| unsafe { x.unwrap_unchecked() })",
			"        .skip_while(is_skip_char)",
			"        .take_while(|c| !is_skip_char(c))",
			"        .collect::<Vec<_>>();",
			"    unsafe { from_utf8_unchecked(&buf) }",
			"        .parse()",
			"        .map_err(|_| Error::new(ErrorKind::Other, \"could not parse value\"))",
			"        .unwrap()",
			"}",
			"pub fn read_line(&mut self) -> String {",
			"    let mut res = String::new();",
			"    unsafe {",
			"        self.input.read_line(&mut res).unwrap_unchecked();",
			"    }",
			"    res.trim_end().to_string()",
			"}",
			"pub fn read_all(&mut self) -> String {",
			"    let mut res = String::new();",
			"    unsafe { self.input.read_to_string(&mut res).unwrap_unchecked() };",
			"    res",
			"}",
			"pub fn read_char(&mut self) -> char {",
			"    self.input",
			"        .by_ref()",
			"        .bytes()",
			"        .map(|b| b.expect(\"could not read bytes in io read operation\"))",
			"        .find(|&b| b != b' ' && b != b'\\n' && b != b'\\r' && b != b'\\t' && b != b',')",
			"        .unwrap() as char",
			"}",
			"pub fn chars(&mut self) -> Vec<char> {",
			"    self.r::<String>().chars().collect()",
			"}",
			"pub fn vec<T: FromStr>(&mut self, n: usize) -> Vec<T> {",
			"    (0..n).map(|_| self.r::<T>()).collect()",
			"}",
			"pub fn line_io(",
			"    &mut self,",
			") -> impl std::iter::Iterator<Item = IoInner<Cursor<String>, Stdout>> {",
			"    let file = self.read_all();",
			"    file.lines()",
			"        .map(move |line| IoInner::from_string(line.to_string()))",
			"        .collect::<Vec<IoInner<Cursor<String>, Stdout>>>()",
			"        .into_iter()",
			"}",
			"pub fn blocks(&mut self) -> Vec<IoInner<Cursor<String>, Stdout>> {",
			"    self.split(\"\\n\\n\")",
			"}",
			"pub fn split(&mut self, pattern: &str) -> Vec<IoInner<Cursor<String>, Stdout>> {",
			"    let file = self.read_all();",
			"    file.split(pattern)",
			"        .map(move |line| IoInner::from_string(line.to_string()))",
			"        .collect::<Vec<IoInner<Cursor<String>, Stdout>>>()",
			"}",
			"pub fn w<T: Display>(&mut self, t: T) {",
			"    unsafe { write!(&mut self.output, \"{t}\").unwrap_unchecked() };",
			"}",
			"pub fn wl<T: Display>(&mut self, t: T) {",
			"    self.w(t);",
			"    self.nl();",
			"    self.flush();",
			"}",
			"pub fn nl(&mut self) {",
			"    self.w('\\n');",
			"}",
			"pub fn flush(&mut self) {",
			"    unsafe { self.output.flush().unwrap_unchecked() }",
			"}",
			"}",
			"#[macro_export]",
			"macro_rules! wf {",
			"(\\$(\\$arg:tt)*) => {",
			"    {",
			"        let io = unsafe {",
			"            IO.as_mut().unwrap_unchecked()",
			"        };",
			"        io.w(format!(\\$(\\$arg)*));",
			"        io.nl();",
			"    }",
			"};",
			"}",
			"#[macro_export]",
			"macro_rules! w {",
			"(\\$v:expr) => {",
			"    {",
			"        let io = unsafe {",
			"            IO.as_mut().unwrap_unchecked()",
			"        };",
			"        io.w(\\$v);io.nl();",
			"    }",
			"};",
			"(\\$(\\$v:expr);*, \\$l:expr) => {",
			"    {",
			"        let io = unsafe {",
			"            IO.as_mut().unwrap_unchecked()",
			"        };",
			"        \\$(",
			"            io.w(\\$v);",
			"            io.w(' ');",
			"        )*",
			"        io.w(\\$l);",
			"        io.nl();",
			"    }",
			"};",
			"(\\$(\\$v:expr),*) => {",
			"    {",
			"        let io = unsafe {",
			"            IO.as_mut().unwrap_unchecked()",
			"        };",
			"        \\$(",
			"            io.w(\\$v);",
			"            io.w(' ');",
			"        )*",
			"        io.nl();",
			"    }",
			"}",
			"}",
			"#[macro_export]",
			"macro_rules! r {",
			"(\\$T:ty) => {",
			"    {",
			"        let io = unsafe {",
			"            IO.as_mut().unwrap_unchecked()",
			"        };",
			"        io.r::<\\$T>()",
			"    }",
			"};",
			"(\\$(\\$T:ty),*) => {",
			"    {",
			"        let io = unsafe {",
			"        IO.as_mut().unwrap_unchecked()",
			"        };",
			"        (\\$(",
			"        io.r::<\\$T>()",
			"        ),*)",
			"    }",
			"}",
			"}",
			"#[macro_export]",
			"macro_rules! init {",
			"(\\$val:expr, \\$(\\$dims:expr);+) => {",
			"{",
			"    let mut temp_vec = Vec::new();",
			"    build_vec!(&mut temp_vec, \\$val, \\$(\\$dims),+);",
			"    temp_vec",
			"}",
			"};",
			"}",
			"",
			"#[macro_export]",
			"macro_rules! build_vec {",
			"(\\$vec:expr, \\$val:expr, \\$dim:expr) => {{",
			"    for _ in 0..\\$dim {",
			"        \\$vec.push(\\$val);",
			"    }",
			"}};",
			"",
			"(\\$vec:expr, \\$val:expr, \\$dim:expr, \\$(\\$rest:expr),+) => {{",
			"    for _ in 0..\\$dim {",
			"        let mut sub_vec = Vec::new();",
			"        build_vec!(&mut sub_vec, \\$val, \\$(\\$rest),+);",
			"        \\$vec.push(sub_vec);",
			"    }",
			"}};",
			"}",
			"}",
		]
	},
	"trie": {
		"scope": "rust",
		"prefix": "trie",
		"body": [
			"$0",
			"#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]",
			"pub struct Vertex<const K: usize> {",
			"    next: [u32; K],",
			"    output: bool,",
			"}",
			"impl<const K: usize> Vertex<K> {",
			"    pub fn new() -> Self {",
			"        Self {",
			"            next: [u32::MAX; K],",
			"            output: false,",
			"        }",
			"    }",
			"}",
			"",
			"#[derive(Clone, Debug)]",
			"pub struct Trie<const K: usize> {",
			"    pub vertices: Vec<Vertex<K>>,",
			"}",
			"impl<const K: usize> Trie<K> {",
			"    pub fn new() -> Self {",
			"        Self {",
			"            vertices: vec![Vertex::new()],",
			"        }",
			"    }",
			"",
			"    pub fn add_string(&mut self, s: &[usize]) -> usize {",
			"        let mut v = 0;",
			"        for c in s {",
			"            if self.vertices[v].next[*c] == u32::MAX {",
			"                self.vertices[v].next[*c] = self.vertices.len() as u32;",
			"                self.vertices.push(Vertex::new());",
			"            }",
			"            v = self.vertices[v].next[*c] as usize;",
			"        }",
			"        self.vertices[v].output = true;",
			"        v",
			"    }",
			"",
			"    pub fn go(&mut self, v: usize, c: usize) -> Option<usize> {",
			"        (self.vertices[v].next[c] != u32::MAX).then_some(self.vertices[v].next[c] as usize)",
			"    }",
			"}",
		]
	},
	"z": {
		"scope": "rust",
		"prefix": "z",
		"body": [
			"$0",
			"pub fn z(s: &str) -> Vec<usize> {",
			"    let n = s.len();",
			"    let s = s.chars().cv();",
			"    let mut z = vec![0; n];",
			"    let mut l = 0;",
			"    let mut r = 0;",
			"    for i in 1..n {",
			"        if i < r {",
			"            z[i] = std::cmp::min(r - i, z[i - l]);",
			"        }",
			"        while i + z[i] < n && s[z[i]] == s[i + z[i]] {",
			"            z[i] += 1;",
			"        }",
			"        if i + z[i] > r {",
			"            l = i;",
			"            r = i + z[i];",
			"        }",
			"    }",
			"    z",
			"}",
		]
	},
}
