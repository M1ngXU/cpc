{
	"z": {
		"scope": "rust",
		"prefix": "z",
		"body": [
			"$0",
			"pub fn z(s: &str) -> Vec<usize> {",
			"    let n = s.len();",
			"    let s = s.chars().cv();",
			"    let mut z = vec![0; n];",
			"    let mut l = 0;",
			"    let mut r = 0;",
			"    for i in 1..n {",
			"        if i < r {",
			"            z[i] = std::cmp::min(r - i, z[i - l]);",
			"        }",
			"        while i + z[i] < n && s[z[i]] == s[i + z[i]] {",
			"            z[i] += 1;",
			"        }",
			"        if i + z[i] > r {",
			"            l = i;",
			"            r = i + z[i];",
			"        }",
			"    }",
			"    z",
			"}"
		]
	},
	"flows": {
		"scope": "rust",
		"prefix": "flows",
		"body": [
			"$0",
			"use std::cmp::Reverse;",
			"use std::collections::BinaryHeap;",
			"/// Ford-Fulkerson flow/min-cut calculation, can modify (only increase?) capacities after max flow",
			"/// calculation",
			"#[derive(Debug, Clone, PartialEq, Eq)]",
			"pub struct FFFlows {",
			"    network: Vec<Vec<(usize, usize)>>,",
			"    rev: Vec<Vec<(usize, usize)>>,",
			"    indeces: Vec<HashMap<usize, usize>>,",
			"    flow: Vec<Vec<usize>>,",
			"}",
			"impl FFFlows {",
			"    pub fn new(network: Vec<Vec<(usize, usize)>>) -> Self {",
			"        let flow = network.iter().map(|e| vec![0; e.len()]).cv();",
			"        let mut rev = vec![vec![]; network.len()];",
			"        let mut indeces = vec![HashMap::new(); network.len()];",
			"        for (u, e) in network.iter().enumerate() {",
			"            for (i, (v, _)) in e.iter().enumerate() {",
			"                indeces[u].insert(*v, i);",
			"                rev[*v].push((u, i));",
			"            }",
			"        }",
			"        Self {",
			"            flow,",
			"            indeces,",
			"            rev,",
			"            network,",
			"        }",
			"    }",
			"",
			"    /// Calculate the maximum flow between source/sink, use `max_flow != 0` if some capacities were",
			"    /// increased",
			"    pub fn calculate(",
			"        &mut self,",
			"        mut max_flow: usize,",
			"        source: usize,",
			"        sink: usize,",
			"    ) -> (usize, Vec<bool>) {",
			"        loop {",
			"            match self.find_augmenting_path(source, sink) {",
			"                Ok(augmenting_path) => {",
			"                    max_flow += augmenting_path.get(0).map(|x| x.3).unwrap_or(0).abs() as usize;",
			"                    for (_, u, i, increase) in augmenting_path {",
			"                        if increase > 0 {",
			"                            self.flow[u][i] += increase as usize;",
			"                        } else {",
			"                            self.flow[u][i] -= (-increase) as usize;",
			"                        }",
			"                    }",
			"                }",
			"                Err(cut) => {",
			"                    return (max_flow, cut);",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"    fn find_augmenting_path(",
			"        &self,",
			"        source: usize,",
			"        sink: usize,",
			"    ) -> Result<Vec<(usize, usize, usize, isize)>, Vec<bool>> {",
			"        let mut parent = vec![(usize::MAX, usize::MAX, usize::MAX, 0_isize); self.network.len()];",
			"        let mut dists = vec![usize::MAX; self.network.len()];",
			"        parent[source].0 = source;",
			"        dists[source] = 0;",
			"        let mut todo = BinaryHeap::new();",
			"        todo.push((Reverse(0), source));",
			"        while let Some((Reverse(d), u)) = todo.pop() {",
			"            if dists[u] < d {",
			"                continue;",
			"            }",
			"            if u == sink {",
			"                let mut path = Vec::new();",
			"                let mut cur = parent[sink];",
			"                while cur.1 != usize::MAX {",
			"                    path.push(cur);",
			"                    cur = parent[cur.0];",
			"                }",
			"                path.reverse();",
			"                let eps = path.iter().map(|x| x.3.abs()).mn();",
			"                eprintln!(\"{eps}\");",
			"                for x in &mut path {",
			"                    x.3 = x.3.clamp(-eps, eps);",
			"                }",
			"                return Ok(path);",
			"            }",
			"            for (i, ((v, capacity), flow)) in self.network[u].iter().zip(&self.flow[u]).enumerate()",
			"            {",
			"                if flow < capacity {",
			"                    let diff = capacity - flow;",
			"                    if dists[*v] > d + diff {",
			"                        dists[*v] = d + diff;",
			"                        parent[*v] = (u, u, i, diff as isize);",
			"                        todo.push((Reverse(d + diff), *v));",
			"                    }",
			"                }",
			"            }",
			"            for (v, i) in &self.rev[u] {",
			"                let diff = self.flow[*v][*i];",
			"                if diff > 0 {",
			"                    if dists[*v] > d + diff {",
			"                        dists[*v] = d + diff;",
			"                        parent[*v] = (u, *v, *i, -(diff as isize));",
			"                        todo.push((Reverse(d + diff), *v));",
			"                    }",
			"                }",
			"            }",
			"        }",
			"        Err(parent.into_iter().map(|(p, _, _, _)| p != usize::MAX).cv())",
			"    }",
			"",
			"    pub fn increase_capacity(&mut self, u: usize, v: usize, increase_by: usize) {",
			"        self.network[u][self.indeces[u][&v]].1 += increase_by;",
			"    }",
			"",
			"    pub fn get_capacity(&self, u: usize, v: usize) -> Option<usize> {",
			"        self.indeces[u].get(&v).map(|&i| self.network[u][i].1)",
			"    }",
			"",
			"    pub fn get_flow(&self, u: usize, v: usize) -> Option<usize> {",
			"        self.indeces[u].get(&v).map(|&i| self.flow[u][i])",
			"    }",
			"}",
			""
		]
	},
	"adj": {
		"scope": "rust",
		"prefix": "adj",
		"body": [
			"$0",
			"let adj = |i, j| {",
			"    [(-1, 0), (0, 1), (0, -1), (1, 0)]",
			"        .into_iter()",
			"        .map(move |(x, y)| (i as isize + x, j as isize + y))",
			"        .filter(|&(i, j)| 0 <= i && i < n as isize && 0 <= j && j < m as isize)",
			"        .map(|(i, j)| (i as usize, j as usize))",
			"};"
		]
	},
	"good_primes.txt": {
		"scope": "rust",
		"prefix": "good_primes.txt",
		"body": [
			"$0",
			"type N = Mod<156859239850691603>;",
			"const K: N = N::new(3414519959);"
		]
	},
	"modint": {
		"scope": "rust",
		"prefix": "modint",
		"body": [
			"$0",
			"// const MOD: usize = 998_244_353;",
			"// const MOD: usize = 1_000_000_007;",
			"type N = Mod;",
			"",
			"use std::ops::*;",
			"",
			"#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default, Debug)]",
			"pub struct Mod(pub usize);",
			"#[allow(unused)]",
			"impl Mod {",
			"    const ZERO: Self = Self::new(0);",
			"    const NEG_ONE: Self = Self::newi(-1);",
			"    const ONE: Self = Self::new(1);",
			"    const TWO: Self = Self::new(2);",
			"    const NEG_TWO: Self = Self::newi(-2);",
			"    const INV_TWO: Self = Self::new(2).inv();",
			"",
			"    pub const fn newi(x: isize) -> Self {",
			"        Self::new(((x % MOD as isize) + MOD as isize) as usize)",
			"    }",
			"",
			"    fn new2(x: usize) -> Self {",
			"        debug_assert!(x < MOD << 1);",
			"        if x >= MOD {",
			"            Self(x - MOD)",
			"        } else {",
			"            Self(x)",
			"        }",
			"    }",
			"",
			"    pub const fn new(x: usize) -> Self {",
			"        Self(x % MOD)",
			"    }",
			"    pub const fn pow(self, mut e: usize) -> Self {",
			"        let mut res = Self(1);",
			"        let mut cur = self;",
			"        while e > 0 {",
			"            if e & 1 == 1 {",
			"                res = res.fast_mul(cur);",
			"            }",
			"            cur = cur.fast_mul(cur);",
			"            e >>= 1;",
			"        }",
			"        res",
			"    }",
			"    pub const fn inv(self) -> Self {",
			"        #[cfg(debug_assertions)]",
			"        if self.0 == 0 {",
			"            panic!(\"Division by `0`.\");",
			"        }",
			"        self.pow(MOD - 2)",
			"    }",
			"",
			"    pub const fn fast_mul(self, rhs: Self) -> Self {",
			"        if MOD < u32::MAX as usize {",
			"            Self((self.0 * rhs.0) % MOD)",
			"        } else {",
			"            Self(((self.0 as u128 * rhs.0 as u128) % MOD as u128) as usize)",
			"        }",
			"    }",
			"}",
			"impl std::iter::Sum for Mod {",
			"    fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {",
			"        iter.fold(Self::ZERO, |a, b| a + b)",
			"    }",
			"}",
			"impl std::iter::Product for Mod {",
			"    fn product<I: Iterator<Item = Self>>(iter: I) -> Self {",
			"        iter.fold(Self::ONE, |a, b| a * b)",
			"    }",
			"}",
			"impl std::fmt::Display for Mod {",
			"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
			"        f.pad_integral(true, \"\", &self.0.to_string())",
			"    }",
			"}",
			"impl AsRef<usize> for Mod {",
			"    fn as_ref(&self) -> &usize {",
			"        &self.0",
			"    }",
			"}",
			"impl AsMut<usize> for Mod {",
			"    fn as_mut(&mut self) -> &mut usize {",
			"        &mut self.0",
			"    }",
			"}",
			"impl Add for Mod {",
			"    type Output = Self;",
			"    fn add(self, rhs: Self) -> Self {",
			"        Self::new2(self.0 + rhs.0)",
			"    }",
			"}",
			"impl Add<usize> for Mod {",
			"    type Output = Self;",
			"    fn add(self, rhs: usize) -> Self {",
			"        self + Self::new(rhs)",
			"    }",
			"}",
			"impl Sub for Mod {",
			"    type Output = Self;",
			"    fn sub(self, rhs: Self) -> Self {",
			"        Self::new2(self.0 + MOD - rhs.0)",
			"    }",
			"}",
			"impl Sub<usize> for Mod {",
			"    type Output = Self;",
			"    fn sub(self, rhs: usize) -> Self {",
			"        self - Self::new(rhs)",
			"    }",
			"}",
			"impl Mul for Mod {",
			"    type Output = Self;",
			"    fn mul(self, rhs: Self) -> Self {",
			"        self.fast_mul(rhs)",
			"    }",
			"}",
			"impl Mul<usize> for Mod {",
			"    type Output = Self;",
			"    fn mul(self, rhs: usize) -> Self {",
			"        if MOD < u32::MAX as usize {",
			"            Self((self.0 * rhs) % MOD)",
			"        } else {",
			"            Self(((self.0 as u128 * rhs as u128) % MOD as u128) as usize)",
			"        }",
			"    }",
			"}",
			"impl Div for Mod {",
			"    type Output = Self;",
			"    fn div(self, rhs: Self) -> Self {",
			"        self * rhs.inv()",
			"    }",
			"}",
			"impl Div<usize> for Mod {",
			"    type Output = Self;",
			"    fn div(self, rhs: usize) -> Self {",
			"        self * Mod::new(rhs).inv()",
			"    }",
			"}",
			"impl Neg for Mod {",
			"    type Output = Self;",
			"",
			"    fn neg(self) -> Self::Output {",
			"        if self.0 == 0 {",
			"            self",
			"        } else {",
			"            Self(MOD - self.0)",
			"        }",
			"    }",
			"}",
			"impl Neg for &Mod {",
			"    type Output = Mod;",
			"",
			"    fn neg(self) -> Self::Output {",
			"        -*self",
			"    }",
			"}",
			"macro_rules! impl_mod_rest {",
			"    (\\$(\\$trait:ident::\\$fn:ident:\\$trait_assign:ident::\\$fn_assign:ident;)*) => {",
			"        \\$(",
			"            impl \\$trait<&Mod> for Mod {",
			"                type Output = Mod;",
			"",
			"                fn \\$fn(self, rhs: &Mod) -> Self::Output {",
			"                    \\$trait::\\$fn(self, *rhs)",
			"                }",
			"            }",
			"            impl \\$trait<&Mod> for &Mod {",
			"                type Output = Mod;",
			"",
			"                fn \\$fn(self, rhs: &Mod) -> Self::Output {",
			"                    \\$trait::\\$fn(*self, *rhs)",
			"                }",
			"            }",
			"            impl \\$trait<Mod> for &Mod {",
			"                type Output = Mod;",
			"",
			"                fn \\$fn(self, rhs: Mod) -> Self::Output {",
			"                    \\$trait::\\$fn(*self, rhs)",
			"                }",
			"            }",
			"            impl \\$trait<&usize> for Mod {",
			"                type Output = Mod;",
			"",
			"                fn \\$fn(self, rhs: &usize) -> Self::Output {",
			"                    \\$trait::\\$fn(self, *rhs)",
			"                }",
			"            }",
			"            impl \\$trait<&usize> for &Mod {",
			"                type Output = Mod;",
			"",
			"                fn \\$fn(self, rhs: &usize) -> Self::Output {",
			"                    \\$trait::\\$fn(*self, *rhs)",
			"                }",
			"            }",
			"            impl \\$trait<usize> for &Mod {",
			"                type Output = Mod;",
			"",
			"                fn \\$fn(self, rhs: usize) -> Self::Output {",
			"                    \\$trait::\\$fn(*self, rhs)",
			"                }",
			"            }",
			"            impl \\$trait_assign for Mod {",
			"                fn \\$fn_assign(&mut self, rhs: Mod) {",
			"                    *self = \\$trait::\\$fn(*self, rhs);",
			"                }",
			"            }",
			"            impl \\$trait_assign<&Mod> for Mod {",
			"                fn \\$fn_assign(&mut self, rhs: &Mod) {",
			"                    *self = \\$trait::\\$fn(*self, rhs);",
			"                }",
			"            }",
			"            impl \\$trait_assign<usize> for Mod {",
			"                fn \\$fn_assign(&mut self, rhs: usize) {",
			"                    *self = \\$trait::\\$fn(*self, rhs);",
			"                }",
			"            }",
			"            impl \\$trait_assign<&usize> for Mod {",
			"                fn \\$fn_assign(&mut self, rhs: &usize) {",
			"                    *self = \\$trait::\\$fn(*self, rhs);",
			"                }",
			"            }",
			"        )*",
			"    };",
			"}",
			"impl_mod_rest! {",
			"    Add::add:AddAssign::add_assign;",
			"    Sub::sub:SubAssign::sub_assign;",
			"    Mul::mul:MulAssign::mul_assign;",
			"    Div::div:DivAssign::div_assign;",
			"}"
		]
	},
	"polyprod": {
		"scope": "rust",
		"prefix": "polyprod",
		"body": [
			"$0",
			"pub fn polyprod(p: Vec<Vec<isize>>, m: isize) -> Vec<isize> {",
			"    let mut polynomials = std::collections::BinaryHeap::new();",
			"    for p in p {",
			"        polynomials.push(Comparator(p));",
			"    }",
			"    while polynomials.len() > 1 {",
			"        let x = Comparator(",
			"            multiply(&polynomials.pop().unwrap().0, &polynomials.pop().unwrap().0)",
			"                .into_iter()",
			"                .map(|x| x % m)",
			"                .cv(),",
			"        );",
			"        polynomials.push(x);",
			"    }",
			"    polynomials.pop().unwrap().0",
			"}",
			"",
			"#[derive(Debug)]",
			"struct Comparator(Vec<I>);",
			"impl PartialEq for Comparator {",
			"    fn eq(&self, other: &Self) -> bool {",
			"        self.cmp(other).is_eq()",
			"    }",
			"}",
			"impl Eq for Comparator {}",
			"impl Ord for Comparator {",
			"    fn cmp(&self, other: &Self) -> std::cmp::Ordering {",
			"        self.0.len().cmp(&other.0.len()).reverse()",
			"    }",
			"}",
			"impl PartialOrd for Comparator {",
			"    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {",
			"        Some(self.cmp(other))",
			"    }",
			"}"
		]
	},
	"hld": {
		"scope": "rust",
		"prefix": "hld",
		"body": [
			"$0",
			"use std::mem::swap;",
			"",
			"pub struct Hld {",
			"    heavy: Vec<usize>,",
			"    in_num: Vec<usize>,",
			"    out_num: Vec<usize>,",
			"    light: Vec<usize>,",
			"    depth: Vec<usize>,",
			"}",
			"impl Hld {",
			"    fn max_subtree(",
			"        u: usize,",
			"        graph: &mut Vec<Vec<usize>>,",
			"        subtree_sizes: &mut Vec<usize>,",
			"        max: &mut Vec<usize>,",
			"        light: &mut Vec<usize>,",
			"        depth: &mut Vec<usize>,",
			"    ) {",
			"        subtree_sizes[u] = 0;",
			"        for i in (0..graph[u].len()).rev() {",
			"            let v = graph[u][i];",
			"            if depth[v] != usize::MAX {",
			"                if max[u] == graph[u].len() - 1 {",
			"                    max[u] = i;",
			"                }",
			"                graph[u].swap_remove(i);",
			"                continue;",
			"            }",
			"            light[v] = u;",
			"            depth[v] = depth[u] + 1;",
			"            Self::max_subtree(v, graph, subtree_sizes, max, light, depth);",
			"            subtree_sizes[u] += subtree_sizes[v];",
			"            if subtree_sizes[graph[u][max[u]]] < subtree_sizes[v] {",
			"                max[u] = i;",
			"            }",
			"        }",
			"    }",
			"",
			"    fn hld(",
			"        u: usize,",
			"        graph: &Vec<Vec<usize>>,",
			"        max: &Vec<usize>,",
			"        in_num: &mut Vec<usize>,",
			"        out_num: &mut Vec<usize>,",
			"        heavy: &mut Vec<usize>,",
			"        ctr: &mut usize,",
			"    ) {",
			"        in_num[u] = *ctr;",
			"        *ctr += 1;",
			"",
			"        if !graph[u].is_empty() {",
			"            heavy[graph[u][max[u]]] = heavy[u];",
			"            Self::hld(graph[u][max[u]], graph, max, in_num, out_num, heavy, ctr);",
			"        }",
			"        for (i, v) in graph[u].iter().enumerate() {",
			"            if max[u] == i {",
			"                continue;",
			"            };",
			"            heavy[*v] = *v;",
			"            Self::hld(*v, graph, max, in_num, out_num, heavy, ctr);",
			"        }",
			"",
			"        out_num[u] = *ctr;",
			"    }",
			"",
			"    pub fn new(mut graph: Vec<Vec<usize>>) -> Self {",
			"        let n = graph.len();",
			"        let mut subtree_sizes = vec![0; n];",
			"        let mut max = vec![0; n];",
			"        let mut light = vec![0; n];",
			"        let mut depth = vec![usize::MAX; n];",
			"        depth[0] = 0;",
			"        Self::max_subtree(",
			"            0,",
			"            &mut graph,",
			"            &mut subtree_sizes,",
			"            &mut max,",
			"            &mut light,",
			"            &mut depth,",
			"        );",
			"        let mut in_num = subtree_sizes; // reuse :)",
			"        let mut out_num = vec![0; n];",
			"        let mut heavy = vec![0; n];",
			"        Self::hld(",
			"            0,",
			"            &graph,",
			"            &max,",
			"            &mut in_num,",
			"            &mut out_num,",
			"            &mut heavy,",
			"            &mut 0,",
			"        );",
			"",
			"        Self {",
			"            in_num,",
			"            out_num,",
			"            heavy,",
			"            light,",
			"            depth,",
			"        }",
			"    }",
			"",
			"    fn is_ancestor(&self, a: usize, b: usize) -> bool {",
			"        self.in_num[a] <= self.in_num[b] && self.out_num[b] <= self.out_num[a]",
			"    }",
			"",
			"    pub fn query(&self, mut a: usize, mut b: usize) -> Vec<(usize, usize)> {",
			"        let mut segments = vec![];",
			"        while a != b {",
			"            if self.is_ancestor(b, a) {",
			"                swap(&mut a, &mut b);",
			"            }",
			"            if self.is_ancestor(a, b) && self.is_ancestor(self.heavy[b], a) {",
			"                // a is on the heavy path from b",
			"                segments.push((self.in_num[a], self.in_num[b]));",
			"                b = a;",
			"                continue;",
			"            }",
			"            if self.depth[self.heavy[a]] < self.depth[self.heavy[b]] {",
			"                swap(&mut a, &mut b);",
			"            }",
			"            segments.push((self.in_num[self.heavy[a]], self.in_num[a]));",
			"            a = self.light[self.heavy[a]];",
			"        }",
			"        if !segments",
			"            .last()",
			"            .is_some_and(|x| x.0 == self.in_num[a] || x.1 == self.in_num[a])",
			"        {",
			"            segments.push((self.in_num[a], self.in_num[a]));",
			"        }",
			"        segments",
			"    }",
			"",
			"    pub fn lca(&self, mut a: usize, mut b: usize) -> usize {",
			"        while a != b {",
			"            if self.is_ancestor(b, a) {",
			"                swap(&mut a, &mut b);",
			"            }",
			"            if self.is_ancestor(a, b) && self.is_ancestor(self.heavy[b], a) {",
			"                // a is on the heavy path from b",
			"                b = a;",
			"                continue;",
			"            }",
			"            if self.depth[self.heavy[a]] < self.depth[self.heavy[b]] {",
			"                swap(&mut a, &mut b);",
			"            }",
			"            a = self.light[self.heavy[a]];",
			"        }",
			"        a",
			"    }",
			"}"
		]
	},
	"fenwick_tree": {
		"scope": "rust",
		"prefix": "fenwick_tree",
		"body": [
			"$0",
			"pub struct FenwickTree {",
			"    tree: Vec<FenwickTreeType>,",
			"}",
			"impl FenwickTree {",
			"    pub fn new(n: usize) -> Self {",
			"        Self {",
			"            tree: vec![DEFAULT; n],",
			"        }",
			"    }",
			"",
			"    pub fn query(&self, mut i: usize) -> FenwickTreeType {",
			"        i += 1;",
			"        let mut sum = 0;",
			"        while i > 0 {",
			"            sum += self.tree[i - 1];",
			"            i -= ((i as isize) & -(i as isize)) as usize;",
			"        }",
			"        sum",
			"    }",
			"",
			"    pub fn update(&mut self, mut i: usize, v: FenwickTreeType) {",
			"        i += 1;",
			"        while i <= self.tree.len() {",
			"            self.tree[i - 1] += v;",
			"            i += ((i as isize) & -(i as isize)) as usize;",
			"        }",
			"    }",
			"}",
			"type FenwickTreeType = I;",
			"const DEFAULT: FenwickTreeType = FenwickTreeType::default();"
		]
	},
	"combinatorics": {
		"scope": "rust",
		"prefix": "combinatorics",
		"body": [
			"$0",
			"static mut SEEN: Vec<(N, N)> = Vec::new();",
			"",
			"#[allow(static_mut_refs)]",
			"fn get_seen() -> &'static mut Vec<(N, N)> {",
			"    unsafe { &mut SEEN }",
			"}",
			"",
			"/// use `init_seen` to get initial \"dp\" memoization table, doubles size on miss (why not)",
			"pub trait Combinatorics {",
			"    fn choose(self, k: usize) -> N;",
			"    fn fact(self) -> N;",
			"    fn inv_fact(self) -> N;",
			"}",
			"impl Combinatorics for usize {",
			"    fn choose(self, k: usize) -> N {",
			"        if self < k {",
			"            N::ZERO",
			"        } else {",
			"            self.fact() * (self - k).inv_fact() * k.inv_fact()",
			"        }",
			"    }",
			"    fn fact(self) -> N {",
			"        let seen = get_seen();",
			"        while self >= seen.len() {",
			"            init_seen(seen);",
			"        }",
			"        seen[self].0",
			"    }",
			"    fn inv_fact(self) -> N {",
			"        let seen = get_seen();",
			"        while self >= seen.len() {",
			"            init_seen(seen);",
			"        }",
			"        seen[self].1",
			"    }",
			"}",
			"fn init_seen(seen: &mut Vec<(N, N)>) {",
			"    if seen.is_empty() {",
			"        seen.push((N::ONE, N::ONE));",
			"    }",
			"    let mut cur = seen.l().0;",
			"    let mut cur_inv = seen.l().1;",
			"    for i in seen.len()..seen.len() * 2 {",
			"        cur *= N::new(i);",
			"        cur_inv /= N::new(i);",
			"        seen.push((cur, cur_inv));",
			"    }",
			"}"
		]
	},
	"rope": {
		"scope": "rust",
		"prefix": "rope",
		"body": [
			"$0",
			"pub struct Rope {",
			"    pub tree: Vec<usize>,",
			"}",
			"impl Rope {",
			"    pub fn new(input: &[usize]) -> Self {",
			"        let n = input.len().next_power_of_two();",
			"        let mut tree = Vec::with_capacity(2 * n - 1);",
			"        unsafe {",
			"            tree.set_len(2 * n - 1);",
			"        }",
			"        tree[n - 1..n - 1 + input.len()].clone_from_slice(input);",
			"        for i in n - 1 + input.len()..2 * n - 1 {",
			"            tree[i] = 0;",
			"        }",
			"        for i in (0..n - 1).rev() {",
			"            tree[i] = tree[2 * i + 1] + tree[2 * i + 2];",
			"        }",
			"        Self { tree }",
			"    }",
			"",
			"    /// Query the segment tree for the range [l, r).",
			"    pub fn query(&self, v: usize) -> Option<usize> {",
			"        self.query_rec(0, 0, (self.tree.len() + 1) >> 1, v)",
			"    }",
			"",
			"    fn query_rec(&self, i: usize, il: usize, ir: usize, v: usize) -> Option<usize> {",
			"        if v == 1 && il + 1 == ir {",
			"            return Some(i - ((self.tree.len() + 1) / 2 - 1));",
			"        }",
			"        let m = (il + ir) >> 1;",
			"        if self.tree[2 * i + 1] < v {",
			"            self.query_rec(2 * i + 2, m, ir, v - self.tree[2 * i + 1])",
			"        } else {",
			"            self.query_rec(2 * i + 1, il, m, v)",
			"        }",
			"    }",
			"",
			"    pub fn update(&mut self, i: usize) {",
			"        let n = (self.tree.len() + 1) / 2;",
			"        let mut i = i + n - 1;",
			"        self.tree[i] = 0;",
			"        while i > 0 {",
			"            i = (i - 1) / 2;",
			"            self.tree[i] = self.tree[2 * i + 1] + self.tree[2 * i + 2];",
			"        }",
			"    }",
			"}"
		]
	},
	"aho_corasick": {
		"scope": "rust",
		"prefix": "aho_corasick",
		"body": [
			"$0",
			"#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]",
			"pub struct Vertex<const K: usize> {",
			"    // can be changed to \"go\" if first all strings are added",
			"    next: [usize; K],",
			"    output: bool,",
			"    parent: usize,",
			"    parent_char: usize,",
			"    link: usize,",
			"    go: [usize; K],",
			"    depth: usize,",
			"}",
			"impl<const K: usize> Vertex<K> {",
			"    pub fn new(parent: usize, parent_char: usize, depth: usize) -> Self {",
			"        Self {",
			"            go: [usize::MAX; K],",
			"            link: usize::MAX,",
			"            next: [usize::MAX; K],",
			"            output: false,",
			"            depth,",
			"            parent,",
			"            parent_char,",
			"        }",
			"    }",
			"}",
			"",
			"pub type LAhoCorasick = AhoCorasick<26>;",
			"#[derive(Clone, Debug)]",
			"pub struct AhoCorasick<const K: usize> {",
			"    pub vertices: Vec<Vertex<K>>,",
			"}",
			"impl<const K: usize> AhoCorasick<K> {",
			"    pub fn new() -> Self {",
			"        Self {",
			"            vertices: vec![Vertex::new(usize::MAX, usize::MAX, 0)],",
			"        }",
			"    }",
			"",
			"    pub fn add_string(&mut self, s: &[usize]) -> usize {",
			"        let mut v = 0;",
			"        for c in s {",
			"            if self.vertices[v].next[*c] == usize::MAX {",
			"                self.vertices[v].next[*c] = self.vertices.len();",
			"                self.vertices",
			"                    .push(Vertex::new(v, *c, self.vertices[v].depth + 1));",
			"            }",
			"            v = self.vertices[v].next[*c];",
			"        }",
			"        self.vertices[v].output = true;",
			"        v",
			"    }",
			"",
			"    pub fn go(&mut self, v: usize, c: usize) -> usize {",
			"        if self.vertices[v].go[c] == usize::MAX {",
			"            if self.vertices[v].next[c] != usize::MAX {",
			"                self.vertices[v].go[c] = self.vertices[v].next[c];",
			"            } else {",
			"                self.vertices[v].go[c] = if v == 0 {",
			"                    0",
			"                } else {",
			"                    let l = self.get_link(v);",
			"                    self.go(l, c)",
			"                };",
			"            }",
			"        }",
			"        self.vertices[v].go[c]",
			"    }",
			"",
			"    fn get_link(&mut self, v: usize) -> usize {",
			"        if self.vertices[v].link == usize::MAX {",
			"            if v == 0 || self.vertices[v].parent == 0 {",
			"                self.vertices[v].link = 0;",
			"            } else {",
			"                let l = self.get_link(self.vertices[v].parent);",
			"                self.vertices[v].link = self.go(l, self.vertices[v].parent_char);",
			"            }",
			"        }",
			"        self.vertices[v].link",
			"    }",
			"}"
		]
	},
	"closest_points": {
		"scope": "rust",
		"prefix": "closest_points",
		"body": [
			"$0",
			"fn min<T: PartialOrd>(a: T, b: T) -> T {",
			"    match a.partial_cmp(&b) {",
			"        Some(std::cmp::Ordering::Less) => a,",
			"        _ => b,",
			"    }",
			"}",
			"",
			"fn point_distance(a: (f64, f64, usize), b: (f64, f64, usize)) -> (f64, usize, usize) {",
			"    let dx = a.0 - b.0;",
			"    let dy = a.1 - b.1;",
			"    (dx * dx + dy * dy, a.2, b.2)",
			"}",
			"",
			"fn closest_points(",
			"    points: &Vec<(f64, f64, usize)>,",
			"    start: usize,",
			"    end: usize,",
			") -> (f64, usize, usize) {",
			"    if end - start <= 1 {",
			"        panic!();",
			"    } else if end - start == 2 {",
			"        point_distance(points[start], points[start + 1])",
			"    } else if end - start == 3 {",
			"        let d1 = point_distance(points[start], points[start + 1]);",
			"        let d2 = point_distance(points[start], points[start + 2]);",
			"        let d3 = point_distance(points[start + 1], points[start + 2]);",
			"        min(d1, min(d2, d3))",
			"    } else {",
			"        let mid = (start + end) >> 1;",
			"        let mut d = min(",
			"            closest_points(points, start, mid),",
			"            closest_points(points, mid, end),",
			"        );",
			"",
			"        let dsqrt = d.0.sqrt();",
			"",
			"        let mut middle = points[start..end]",
			"            .iter()",
			"            .filter(|x| (x.0 - points[mid].0).abs() <= dsqrt)",
			"            .copied()",
			"            .collect::<Vec<_>>();",
			"        middle.sort_by(|(_, y1, _), (_, y2, _)| y1.total_cmp(y2));",
			"",
			"        for i in 0..middle.len() {",
			"            let p1 = middle[i];",
			"            d = middle[i + 1..]",
			"                .iter()",
			"                .take(7)",
			"                .map(|p2| point_distance(p1, *p2))",
			"                .min_by(|p2, p3| p2.partial_cmp(p3).unwrap())",
			"                .map(|d2| min(d, d2))",
			"                .unwrap_or(d);",
			"        }",
			"",
			"        d",
			"    }",
			"}"
		]
	},
	"circumcircle": {
		"scope": "rust",
		"prefix": "circumcircle",
		"body": [
			"$0",
			"#[inline]",
			"fn orient2d(pa: [f64; 2], pb: [f64; 2], pc: [f64; 2]) -> f64 {",
			"    let detleft = (pa[0] - pc[0]) * (pb[1] - pc[1]);",
			"    let detright = (pa[1] - pc[1]) * (pb[0] - pc[0]);",
			"    let det = detleft - detright;",
			"    return det;",
			"}",
			"",
			"type Point = [f64; 2];",
			"",
			"fn circumcircle(a: Point, b: Point, c: Point) -> (Point, f64) {",
			"    let orientation = orient2d(a, b, c);",
			"",
			"    let (b, c, denominator) = if orientation > 0. {",
			"        (b, c, 2. * orientation)",
			"    } else if orientation < 0. {",
			"        (c, b, -2. * orientation)",
			"    } else {",
			"        panic!()",
			"    };",
			"",
			"    let [acx, acy, bcx, bcy, abx, aby] = [",
			"        a[0] - c[0],",
			"        a[1] - c[1],",
			"        b[0] - c[0],",
			"        b[1] - c[1],",
			"        a[0] - b[0],",
			"        a[1] - b[1],",
			"    ];",
			"    let [acxs, acys, bcxs, bcys, abxs, abys] = [",
			"        acx * acx,",
			"        acy * acy,",
			"        bcx * bcx,",
			"        bcy * bcy,",
			"        abx * abx,",
			"        aby * aby,",
			"    ];",
			"    let [acxys, bcxys, abxys] = [acxs + acys, bcxs + bcys, abxs + abys];",
			"    let center = [",
			"        c[0] + (acxys * bcy - bcxys * acy) / denominator,",
			"        c[1] + (acx * bcxys - bcx * acxys) / denominator,",
			"    ];",
			"    let radius = f64::sqrt(bcxys * acxys * abxys) / denominator;",
			"    (center, radius)",
			"}"
		]
	},
	"direct_planar_graph": {
		"scope": "rust",
		"prefix": "direct_planar_graph",
		"body": [
			"$0",
			"// edges must be Vec<HashMap<usize, cost>>",
			"// degree must be mutable",
			"",
			"let mut lowest_degrees = Vec::new();",
			"for i in 0..n {",
			"    if degree[i] <= 5 {",
			"        lowest_degrees.push(i);",
			"    }",
			"}",
			"while let Some(u) = lowest_degrees.pop() {",
			"    for (v, _c) in edges[u].clone() {",
			"        edges[v].remove(&u);",
			"        degree[v] -= 1;",
			"        if degree[v] == 5 {",
			"            lowest_degrees.push(v);",
			"        }",
			"    }",
			"}"
		]
	},
	"complex": {
		"scope": "rust",
		"prefix": "complex",
		"body": [
			"$0",
			"use std::ops::*;",
			"pub type CT = f64;",
			"fn sqrt(x: CT) -> CT {",
			"    x.sqrt()",
			"}",
			"fn sin_cos(x: CT) -> (CT, CT) {",
			"    x.sin_cos()",
			"}",
			"const PI: CT = std::f64::consts::PI;",
			"",
			"#[derive(Clone, Copy, PartialEq)]",
			"pub struct Complex(pub CT, pub CT);",
			"impl std::fmt::Debug for Complex {",
			"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
			"        write!(f, \"{} + {}i\", self.0, self.1)",
			"    }",
			"}",
			"impl Complex {",
			"    pub const ZERO: Complex = Complex(0., 0.);",
			"    pub const ONE: Complex = Complex(1., 0.);",
			"    pub const I: Complex = Complex(0., 1.);",
			"",
			"    pub fn len_sq(&self) -> CT {",
			"        self.0 * self.0 + self.1 * self.1",
			"    }",
			"",
			"    pub fn len(&self) -> CT {",
			"        sqrt(self.len_sq())",
			"    }",
			"}",
			"impl Add for Complex {",
			"    type Output = Self;",
			"",
			"    fn add(self, rhs: Self) -> Self::Output {",
			"        Self(self.0 + rhs.0, self.1 + rhs.1)",
			"    }",
			"}",
			"impl Add<CT> for Complex {",
			"    type Output = Self;",
			"",
			"    fn add(self, rhs: CT) -> Self::Output {",
			"        Self(self.0 + rhs, self.1)",
			"    }",
			"}",
			"impl Sub for Complex {",
			"    type Output = Self;",
			"",
			"    fn sub(self, rhs: Self) -> Self::Output {",
			"        Self(self.0 - rhs.0, self.1 - rhs.1)",
			"    }",
			"}",
			"impl Sub<CT> for Complex {",
			"    type Output = Self;",
			"",
			"    fn sub(self, rhs: CT) -> Self::Output {",
			"        Self(self.0 - rhs, self.1)",
			"    }",
			"}",
			"impl Mul for Complex {",
			"    type Output = Self;",
			"",
			"    fn mul(self, rhs: Self) -> Self::Output {",
			"        Self(",
			"            self.0 * rhs.0 - self.1 * rhs.1,",
			"            self.0 * rhs.1 + self.1 * rhs.0,",
			"        )",
			"    }",
			"}",
			"impl Mul<CT> for Complex {",
			"    type Output = Self;",
			"",
			"    fn mul(self, rhs: CT) -> Self::Output {",
			"        Self(self.0 * rhs, self.1 * rhs)",
			"    }",
			"}",
			"impl Div for Complex {",
			"    type Output = Self;",
			"",
			"    fn div(self, rhs: Self) -> Self::Output {",
			"        self * Self(rhs.0, -rhs.1) / rhs.len_sq()",
			"    }",
			"}",
			"impl Div<CT> for Complex {",
			"    type Output = Self;",
			"",
			"    fn div(self, rhs: CT) -> Self::Output {",
			"        Self(self.0 / rhs, self.1 / rhs)",
			"    }",
			"}",
			"impl Neg for Complex {",
			"    type Output = Complex;",
			"",
			"    fn neg(self) -> Self::Output {",
			"        Complex(-self.0, -self.1)",
			"    }",
			"}",
			"impl Neg for &Complex {",
			"    type Output = Complex;",
			"",
			"    fn neg(self) -> Self::Output {",
			"        Complex(-self.0, -self.1)",
			"    }",
			"}",
			"macro_rules! impl_complex_rest {",
			"    (\\$(\\$trait:ident::\\$fn:ident:\\$trait_assign:ident::\\$fn_assign:ident;)*) => {",
			"        \\$(",
			"            impl \\$trait<&Complex> for Complex {",
			"                type Output = Complex;",
			"",
			"                fn \\$fn(self, rhs: &Complex) -> Self::Output {",
			"                    \\$trait::\\$fn(self, *rhs)",
			"                }",
			"            }",
			"            impl \\$trait<&Complex> for &Complex {",
			"                type Output = Complex;",
			"",
			"                fn \\$fn(self, rhs: &Complex) -> Self::Output {",
			"                    \\$trait::\\$fn(*self, *rhs)",
			"                }",
			"            }",
			"            impl \\$trait<Complex> for &Complex {",
			"                type Output = Complex;",
			"",
			"                fn \\$fn(self, rhs: Complex) -> Self::Output {",
			"                    \\$trait::\\$fn(*self, rhs)",
			"                }",
			"            }",
			"            impl \\$trait<&CT> for Complex {",
			"                type Output = Complex;",
			"",
			"                fn \\$fn(self, rhs: &CT) -> Self::Output {",
			"                    \\$trait::\\$fn(self, *rhs)",
			"                }",
			"            }",
			"            impl \\$trait<&CT> for &Complex {",
			"                type Output = Complex;",
			"",
			"                fn \\$fn(self, rhs: &CT) -> Self::Output {",
			"                    \\$trait::\\$fn(*self, *rhs)",
			"                }",
			"            }",
			"            impl \\$trait<CT> for &Complex {",
			"                type Output = Complex;",
			"",
			"                fn \\$fn(self, rhs: CT) -> Self::Output {",
			"                    \\$trait::\\$fn(*self, rhs)",
			"                }",
			"            }",
			"            impl \\$trait_assign for Complex {",
			"                fn \\$fn_assign(&mut self, rhs: Complex) {",
			"                    *self = \\$trait::\\$fn(*self, rhs);",
			"                }",
			"            }",
			"            impl \\$trait_assign<&Complex> for Complex {",
			"                fn \\$fn_assign(&mut self, rhs: &Complex) {",
			"                    *self = \\$trait::\\$fn(*self, rhs);",
			"                }",
			"            }",
			"            impl \\$trait_assign<CT> for Complex {",
			"                fn \\$fn_assign(&mut self, rhs: CT) {",
			"                    *self = \\$trait::\\$fn(*self, rhs);",
			"                }",
			"            }",
			"            impl \\$trait_assign<&CT> for Complex {",
			"                fn \\$fn_assign(&mut self, rhs: &CT) {",
			"                    *self = \\$trait::\\$fn(*self, rhs);",
			"                }",
			"            }",
			"        )*",
			"    };",
			"}",
			"impl_complex_rest! {",
			"    Add::add:AddAssign::add_assign;",
			"    Sub::sub:SubAssign::sub_assign;",
			"    Mul::mul:MulAssign::mul_assign;",
			"    Div::div:DivAssign::div_assign;",
			"}"
		]
	},
	"tree": {
		"scope": "rust",
		"prefix": "tree",
		"body": [
			"$0",
			"let mut edges = vec![vec![]; n];",
			"for _ in 1..n {",
			"    let (u, v) = r!(usize, usize);",
			"    edges[u - 1].push(v - 1);",
			"    edges[v - 1].push(u - 1);",
			"}"
		]
	},
	"trie": {
		"scope": "rust",
		"prefix": "trie",
		"body": [
			"$0",
			"#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]",
			"pub struct Vertex<const K: usize> {",
			"    next: [u32; K],",
			"    output: bool,",
			"}",
			"impl<const K: usize> Vertex<K> {",
			"    pub fn new() -> Self {",
			"        Self {",
			"            next: [u32::MAX; K],",
			"            output: false,",
			"        }",
			"    }",
			"}",
			"",
			"#[derive(Clone, Debug)]",
			"pub struct Trie<const K: usize> {",
			"    pub vertices: Vec<Vertex<K>>,",
			"}",
			"impl<const K: usize> Trie<K> {",
			"    pub fn new() -> Self {",
			"        Self {",
			"            vertices: vec![Vertex::new()],",
			"        }",
			"    }",
			"",
			"    pub fn add_string(&mut self, s: &[usize]) -> usize {",
			"        let mut v = 0;",
			"        for c in s {",
			"            if self.vertices[v].next[*c] == u32::MAX {",
			"                self.vertices[v].next[*c] = self.vertices.len() as u32;",
			"                self.vertices.push(Vertex::new());",
			"            }",
			"            v = self.vertices[v].next[*c] as usize;",
			"        }",
			"        self.vertices[v].output = true;",
			"        v",
			"    }",
			"",
			"    pub fn go(&mut self, v: usize, c: usize) -> Option<usize> {",
			"        (self.vertices[v].next[c] != u32::MAX).then_some(self.vertices[v].next[c] as usize)",
			"    }",
			"}"
		]
	},
	"lca": {
		"scope": "rust",
		"prefix": "lca",
		"body": [
			"$0",
			"pub struct Lca<const UP: usize = 20> {",
			"    up: Vec<[usize; UP]>,",
			"    tin: Vec<usize>,",
			"    tout: Vec<usize>,",
			"}",
			"impl<const UP: usize> Lca<UP> {",
			"    pub fn new(tree: &Vec<Vec<usize>>) -> Self {",
			"        let mut tin = vec![0; tree.len()];",
			"        let mut tout = vec![0; tree.len()];",
			"        let mut up = vec![[0; UP]; tree.len()];",
			"",
			"        fn dfs<const UP: usize>(",
			"            u: usize,",
			"            p: usize,",
			"            tree: &Vec<Vec<usize>>,",
			"            up: &mut Vec<[usize; UP]>,",
			"            tin: &mut Vec<usize>,",
			"            tout: &mut Vec<usize>,",
			"            t: &mut usize,",
			"        ) {",
			"            *t += 1;",
			"            up[u][0] = p;",
			"            tin[u] = *t;",
			"            for i in 1..up[u].len() {",
			"                up[u][i] = up[up[u][i - 1]][i - 1];",
			"            }",
			"",
			"            for v in &tree[u] {",
			"                if *v != p {",
			"                    dfs(*v, u, tree, up, tin, tout, t);",
			"                }",
			"            }",
			"",
			"            *t += 1;",
			"            tout[u] = *t;",
			"        }",
			"",
			"        dfs(0, 0, tree, &mut up, &mut tin, &mut tout, &mut 0);",
			"",
			"        Self { up, tin, tout }",
			"    }",
			"",
			"    pub fn is_anc(&self, u: usize, v: usize) -> bool {",
			"        self.tin[u] <= self.tin[v] && self.tout[v] <= self.tout[u]",
			"    }",
			"",
			"    /// Returns lca + parent[lca]",
			"    pub fn lca(&self, mut u: usize, v: usize) -> (usize, usize) {",
			"        if self.is_anc(u, v) {",
			"            return (u, self.up[u][0]);",
			"        }",
			"        if self.is_anc(v, u) {",
			"            return (v, self.up[v][0]);",
			"        }",
			"",
			"        for i in (0..self.up[0].len()).rev() {",
			"            if !self.is_anc(self.up[u][i], v) {",
			"                u = self.up[u][i];",
			"            }",
			"        }",
			"        (self.up[u][0], self.up[u][1])",
			"    }",
			"}"
		]
	},
	"template": {
		"scope": "rust",
		"prefix": "template",
		"body": [
			"fn main() {",
			"    let _io = io();",
			"    for _ in 0..r!(U) {",
			"        // let (n, q) = r!(U, U);",
			"        // let n = r!(U);",
			"        // let a = (0..n).map(|_| r!(U)).cv();",
			"        $0",
			"    }",
			"}",
			"",
			"pub fn lcm(u: U, v: U) -> U {",
			"    u * v / gcd(u, v)",
			"}",
			"// gcd from wiki: https://en.wikipedia.org/wiki/Binary_GCD_algorithm",
			"pub fn gcd(mut u: U, mut v: U) -> U {",
			"    if u == 0 {",
			"        return v;",
			"    } else if v == 0 {",
			"        return u;",
			"    }",
			"",
			"    let i = u.trailing_zeros();",
			"    u >>= i;",
			"    let j = v.trailing_zeros();",
			"    v >>= j;",
			"    let k = std::cmp::min(i, j);",
			"    loop {",
			"        if u > v {",
			"            std::mem::swap(&mut u, &mut v);",
			"        }",
			"        v -= u;",
			"        if v == 0 {",
			"            return u << k;",
			"        }",
			"        v >>= v.trailing_zeros();",
			"    }",
			"}",
			"pub struct Rng {",
			"    seed: u32,",
			"}",
			"impl Rng {",
			"    pub fn new() -> Self {",
			"        Self {",
			"            seed: std::time::SystemTime::now()",
			"                .duration_since(std::time::SystemTime::UNIX_EPOCH)",
			"                .unwrap()",
			"                .subsec_nanos(),",
			"        }",
			"    }",
			"",
			"    pub fn next(&mut self) -> u32 {",
			"        self.seed ^= self.seed << 13;",
			"        self.seed ^= self.seed >> 17;",
			"        self.seed ^= self.seed << 5;",
			"        self.seed",
			"    }",
			"",
			"    pub fn next_u64(&mut self) -> u64 {",
			"        let (l, u) = (self.next(), self.next());",
			"        ((l as u64) << 32) | u as u64",
			"    }",
			"",
			"    pub fn next_u128(&mut self) -> u128 {",
			"        let (l, u) = (self.next(), self.next());",
			"        ((l as u128) << 64) | u as u128",
			"    }",
			"",
			"    pub fn next_u(&mut self) -> usize {",
			"        self.next_u64() as usize",
			"    }",
			"}",
			"pub trait IterExt<T> {",
			"    fn n(&mut self) -> T;",
			"    fn cv(self) -> Vec<T>;",
			"}",
			"impl<T, I: Iterator<Item = T>> IterExt<T> for I {",
			"    fn cv(self) -> Vec<T> {",
			"        self.collect()",
			"    }",
			"",
			"    fn n(&mut self) -> T {",
			"        self.next().unwrap()",
			"    }",
			"}",
			"pub trait IterExt2<T: PartialOrd> {",
			"    fn mn(self) -> T;",
			"    fn mx(self) -> T;",
			"}",
			"",
			"impl<T: PartialOrd, I: IntoIterator<Item = T>> IterExt2<T> for I {",
			"    fn mn(self) -> T {",
			"        self.into_iter()",
			"            .min_by(|a, b| a.partial_cmp(b).unwrap())",
			"            .unwrap()",
			"    }",
			"    fn mx(self) -> T {",
			"        self.into_iter()",
			"            .max_by(|a, b| a.partial_cmp(b).unwrap())",
			"            .unwrap()",
			"    }",
			"}",
			"pub trait IterExt3<T: ToString> {",
			"    fn to_string(self, sep: &str) -> String;",
			"}",
			"impl<T: ToString, I: IntoIterator<Item = T>> IterExt3<T> for I {",
			"    fn to_string(self, sep: &str) -> String {",
			"        self.into_iter().map(|x| x.to_string()).cv().join(sep)",
			"    }",
			"}",
			"pub trait IterExt4<T: Clone> {",
			"    fn l(&self) -> T;",
			"}",
			"impl<T: Clone> IterExt4<T> for Vec<T> {",
			"    fn l(&self) -> T {",
			"        self[self.len() - 1].clone()",
			"    }",
			"}",
			"impl<T: Clone> IterExt4<T> for &[T] {",
			"    fn l(&self) -> T {",
			"        self[self.len() - 1].clone()",
			"    }",
			"}",
			"impl<T: Clone> IterExt4<T> for &mut [T] {",
			"    fn l(&self) -> T {",
			"        self[self.len() - 1].clone()",
			"    }",
			"}",
			"",
			"pub use lib::*;",
			"#[allow(unused)]",
			"mod lib {",
			"    pub type U = usize;",
			"    pub type I = isize;",
			"    pub type F = f64;",
			"",
			"    pub use std::cmp::{Ordering, Reverse};",
			"    pub use std::collections::*;",
			"    pub use std::f64::consts::*;",
			"    pub use std::fmt::Write;",
			"    use std::io::*;",
			"    use std::iter::Filter;",
			"    use std::str::{Split, SplitWhitespace};",
			"    pub struct Output(String);",
			"    impl AsRef<String> for Output {",
			"        fn as_ref(&self) -> &String {",
			"            &self.0",
			"        }",
			"    }",
			"    impl AsMut<String> for Output {",
			"        fn as_mut(&mut self) -> &mut String {",
			"            &mut self.0",
			"        }",
			"    }",
			"    static mut OUTPUT: Output = Output(String::new());",
			"    #[inline(always)]",
			"    #[allow(static_mut_refs)]",
			"    pub fn output() -> &'static mut Output {",
			"        unsafe { &mut OUTPUT }",
			"    }",
			"    #[macro_export]",
			"    macro_rules! w {",
			"    () => {{",
			"        let _ = writeln!(output().as_mut());",
			"    }};",
			"    (\\$t:expr) => {{",
			"        let _ = writeln!(output().as_mut(), \"{}\", \\$t);",
			"    }};",
			"    (\\$start:expr \\$(,\\$t:expr)* \\$(,)?) => {{",
			"        let o = output().as_mut();",
			"        let _ = write!(o, \"{}\", \\$start);",
			"        \\$(",
			"            let _ = write!(o, \" {}\", \\$t);",
			"        )*",
			"        let _ = writeln!(o);",
			"    }};",
			"}",
			"    type InputInner = (Split<'static, &'static [char]>, String);",
			"    pub struct Input(InputInner); // must drop both at the same time (or the iterator first)",
			"    impl Input {",
			"        #[inline(always)]",
			"        pub fn get_next(&mut self) -> &'static str {",
			"            loop {",
			"                if let Some(n) = self.0 .0.next() {",
			"                    if !n.is_empty() {",
			"                        return n;",
			"                    }",
			"                } else {",
			"                    self.0 = read_next_line();",
			"                }",
			"            }",
			"        }",
			"    }",
			"    const SKIP_CHARS: [char; 5] = [' ', '\\n', '\\r', '\\t', ','];",
			"    fn read_next_line() -> InputInner {",
			"        let mut s = String::new();",
			"        stdin().read_line(&mut s).unwrap();",
			"        let ss: &'static mut str = unsafe { std::mem::transmute(s.as_mut_str()) };",
			"        (ss.split(&SKIP_CHARS), s)",
			"    }",
			"    static mut INPUT: Option<Input> = None;",
			"    #[inline(always)]",
			"    #[allow(static_mut_refs)]",
			"    pub fn input() -> &'static mut Input {",
			"        unsafe { INPUT.as_mut().unwrap_unchecked() }",
			"    }",
			"    pub trait Parse {",
			"        type ParsesTo;",
			"",
			"        #[inline(always)]",
			"        fn parse(i: &mut Input) -> Self::ParsesTo;",
			"    }",
			"    pub struct IO;",
			"    impl Drop for IO {",
			"        fn drop(&mut self) {",
			"            print!(\"{}\", output().0);",
			"        }",
			"    }",
			"    macro_rules! impl_parse {",
			"    (\\$(\\$t:tt),*) => {",
			"        \\$(",
			"        impl Parse for \\$t {",
			"            type ParsesTo = Self;",
			"",
			"            #[inline(always)]",
			"            fn parse(i: &mut Input) -> Self::ParsesTo {",
			"                <Self as std::str::FromStr>::from_str(&i.get_next()).unwrap()",
			"            }",
			"        }",
			"        )*",
			"    };",
			"}",
			"",
			"    impl_parse!(",
			"        bool, u8, i8, char, u16, i16, u32, i32, f32, u64, i64, f64, usize, isize, u128, i128",
			"    );",
			"    impl Parse for String {",
			"        type ParsesTo = Vec<char>;",
			"",
			"        fn parse(i: &mut Input) -> Self::ParsesTo {",
			"            i.get_next().chars().collect()",
			"        }",
			"    }",
			"    impl<T: Parse<ParsesTo = U>, U> Parse for Vec<T> {",
			"        type ParsesTo = Vec<U>;",
			"",
			"        fn parse(i: &mut Input) -> Self::ParsesTo {",
			"            let n = usize::parse(i);",
			"            (0..n).map(|_| T::parse(i)).collect()",
			"        }",
			"    }",
			"    #[inline(always)]",
			"    pub fn lin<T: Parse<ParsesTo = U>, U, V: FromIterator<U>>(n: usize) -> V {",
			"        let i = input();",
			"        (0..n).map(|_| T::parse(i)).collect()",
			"    }",
			"    #[inline(always)]",
			"    pub fn grid<T: Parse<ParsesTo = U>, U, V: FromIterator<U>, W: FromIterator<V>>(",
			"        n: usize,",
			"        m: usize,",
			"    ) -> W {",
			"        (0..n).map(|_| lin::<T, U, V>(m)).collect()",
			"    }",
			"    #[macro_export]",
			"    macro_rules! rv {",
			"        (\\$n:expr; \\$c:tt<\\$t:tt>) => {",
			"            lin::<\\$t, _, \\$c<_>>(\\$n)",
			"        };",
			"        (\\$n:expr, \\$m:expr; \\$c1:tt<\\$c2:tt<\\$t:tt>>) => {",
			"            grid::<\\$t, _, \\$c2<_>, \\$c1<\\$c2<_>>>(\\$n, \\$m);",
			"        };",
			"    }",
			"    #[macro_export]",
			"    macro_rules! r {",
			"    (\\$(\\$t:ty),* \\$(,)?) => {{",
			"        let i = input();",
			"        (\\$(<\\$t as Parse>::parse(i)),*)",
			"    }};",
			"}",
			"    pub fn io() -> IO {",
			"        let (mut i, mut o) = (Some(Input(read_next_line())), Output(String::new()));",
			"        unsafe {",
			"            INPUT = i;",
			"            OUTPUT = o;",
			"        }",
			"        IO",
			"    }",
			"}"
		]
	},
	"sieve": {
		"scope": "rust",
		"prefix": "sieve",
		"body": [
			"$0",
			"/// lowprime sieve: linear, sieve, primes, divisor",
			"/// computes lp[i] where lp[i] is the lowest prime divisor of i and pr, where pr[i] is the i-th prime number",
			"/// C: O(n), R: nothing",
			"///",
			"/// from: https://github.com/TecTrixer/cp-template/blob/main/template.rs",
			"fn lp(n: U) {",
			"    let mut lp = vec![0; n + 1];",
			"    let mut pr = vec![];",
			"    for i in 2..=n {",
			"        if lp[i] == 0 {",
			"            lp[i] = i;",
			"            pr.push(i);",
			"        }",
			"        let mut j = 0;",
			"        while i * pr[j] <= n {",
			"            lp[i * pr[j]] = pr[j];",
			"            if pr[j] == lp[i] {",
			"                break;",
			"            }",
			"            j += 1;",
			"        }",
			"    }",
			"}"
		]
	},
	"rbtree": {
		"scope": "rust",
		"prefix": "rbtree",
		"body": [
			"$0",
			"use redblack::*;",
			"// modified version of: https://gist.github.com/tylergannon/b15d56121982415d5fd1f9987ae13f34",
			"mod redblack {",
			"    use crate::Rng;",
			"    use std::cmp::Ord;",
			"    use std::cmp::Ordering;",
			"    use std::fmt::Debug;",
			"    use std::iter::IntoIterator;",
			"    use std::iter::Iterator;",
			"    use std::mem::ManuallyDrop;",
			"",
			"    #[derive(Clone)]",
			"    struct Node<K, V> {",
			"        value: V,",
			"        key: K,",
			"        left: Option<usize>,",
			"        right: Option<usize>,",
			"        size: usize,",
			"        color: Color,",
			"        parent: Option<usize>,",
			"    }",
			"",
			"    #[derive(Copy, Clone)]",
			"    struct Color {",
			"        color: bool,",
			"    }",
			"",
			"    impl Color {",
			"        const RED: bool = true;",
			"        const BLACK: bool = false;",
			"        fn red() -> Color {",
			"            Color { color: Color::RED }",
			"        }",
			"        fn black() -> Color {",
			"            Color {",
			"                color: Color::BLACK,",
			"            }",
			"        }",
			"        fn is_red(self) -> bool {",
			"            self.color == Color::RED",
			"        }",
			"        fn flip(&mut self) {",
			"            self.color = !self.color;",
			"        }",
			"    }",
			"",
			"    impl<K, V> Debug for Node<K, V>",
			"    where",
			"        K: Debug,",
			"        V: Debug,",
			"    {",
			"        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
			"            let left = if self.left.is_some() {",
			"                format!(\"{}\", self.left.unwrap())",
			"            } else {",
			"                \"_\".to_string()",
			"            };",
			"            let right = if self.right.is_some() {",
			"                format!(\"{}\", self.right.unwrap())",
			"            } else {",
			"                \"_\".to_string()",
			"            };",
			"            let paren = if self.parent.is_some() {",
			"                format!(\"{}\", self.parent.unwrap())",
			"            } else {",
			"                \"_\".to_string()",
			"            };",
			"            write!(",
			"                f,",
			"                \"Node {:?} parent {} left: {} right: {} k: {:?} v: {:?}, s: {}\",",
			"                self.color, paren, left, right, self.key, self.value, self.size",
			"            )",
			"        }",
			"    }",
			"",
			"    impl Debug for Color {",
			"        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
			"            if self.is_red() {",
			"                write!(f, \"RED\")",
			"            } else {",
			"                write!(f, \"BLACK\")",
			"            }",
			"        }",
			"    }",
			"",
			"    #[derive(Clone)]",
			"    pub struct RBTree<K, V>",
			"    where",
			"        K: Ord,",
			"    {",
			"        root: Option<usize>,",
			"        nodes: Vec<Node<K, V>>,",
			"    }",
			"    impl<K: Debug + Ord, V: Debug> Debug for RBTree<K, V> {",
			"        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
			"            f.debug_map().entries(self.iter()).finish()",
			"        }",
			"    }",
			"",
			"    pub struct DeleteResult {",
			"        child: Option<usize>,",
			"        moved_node: usize,",
			"        moved_node_new_id: usize,",
			"    }",
			"",
			"    impl DeleteResult {",
			"        fn translate(&self, id: usize) -> usize {",
			"            if self.moved_node == id {",
			"                self.moved_node_new_id",
			"            } else {",
			"                id",
			"            }",
			"        }",
			"",
			"        fn set_child(mut self, id: usize) -> DeleteResult {",
			"            self.child = Some(self.translate(id));",
			"            self",
			"        }",
			"    }",
			"",
			"    ///",
			"    /// A Red-Black BST Implementation, using a Vec for storing the actual node data.",
			"    /// Rather than linking directly from one node to another, each node's `left` and `right`",
			"    /// fields contain an `Option<usize>`, where `Some(id)` refers to an index within the `nodes` Vec.",
			"    ///",
			"    /// Inspiration for this approach taken from various examples using a vector-based _arena_.",
			"    ///",
			"    /// The design goals here were to keep the tree data exclusively inside of the vector in order to",
			"    /// take advantage of performance optimizations resulting from use of contiguous blocks of memory.",
			"    ///",
			"    /// It remains to be seen if this actually speeds things up, pending some benchmarking.",
			"    ///",
			"    /// The trick with all recursive data structures I've seen so far, is in satisfying the borrow checker.",
			"    /// This was solved by making it so that all node manipulations are done by moving only `Copy` values,",
			"    /// so as to circumvent the _cannot move from borrowed value_ error.",
			"    ///",
			"    /// The algorithm itself is Robert Sedgewick's algorithm as [written in java](https://algs4.cs.princeton.edu/33balanced/RedBlackBST.java.html).",
			"    /// While I found some discussion online describing O(1) fixups, the implementations seem",
			"    /// overly complex, and I'm satisfied with O(log(N)) fixups.",
			"    ///",
			"    impl<K, V> RBTree<K, V>",
			"    where",
			"        K: Ord,",
			"    {",
			"        pub fn new() -> RBTree<K, V> {",
			"            Self::default()",
			"        }",
			"",
			"        pub fn into_unsorted_vec(self) -> Vec<(K, V)> {",
			"            self.nodes",
			"        }",
			"",
			"        pub fn random(&self) -> Option<(&K, &V)> {",
			"            if self.is_empty() {",
			"                None",
			"            } else {",
			"                let mut rng = Rng::new();",
			"                let r = ((rng.next() as usize) << 32) | rng.next() as usize;",
			"                let rank = r % self.len();",
			"                let node = &self.nodes[self.select_from_node(rank, self.root.unwrap())];",
			"                Some((&node.key, &node.value))",
			"            }",
			"        }",
			"",
			"        pub fn get(&self, key: &K) -> Option<&V> {",
			"            let mut maybe_id = self.root;",
			"            while let Some(id) = maybe_id {",
			"                let node = &self.nodes[id];",
			"                match key.cmp(&node.key) {",
			"                    Ordering::Equal => return Some(&node.value),",
			"                    Ordering::Less => maybe_id = node.left,",
			"                    Ordering::Greater => maybe_id = node.right,",
			"                }",
			"            }",
			"",
			"            None",
			"        }",
			"",
			"        pub fn insert(&mut self, key: K, value: V) {",
			"            self.root = Self::put(self.root, None, key, value, &mut self.nodes);",
			"            self.nodes[self.root.unwrap()].color = Color::black();",
			"            // assert!(self.check());",
			"        }",
			"",
			"        pub fn len(&self) -> usize {",
			"            Self::size(self.root, &self.nodes)",
			"        }",
			"",
			"        pub fn is_empty(&self) -> bool {",
			"            self.root.is_none()",
			"        }",
			"",
			"        /**",
			"         * It returns true if the left and right heights differ by one or zero.",
			"         */",
			"        pub fn is_balanced(&self) -> bool {",
			"            let mut black = 0;",
			"            let mut node = self.root;",
			"            while node.is_some() {",
			"                if !Self::is_red(node, &self.nodes) {",
			"                    black += 1;",
			"                }",
			"                node = self.nodes[node.unwrap()].left;",
			"            }",
			"            self.node_balanced(self.root, black)",
			"        }",
			"",
			"        fn node_balanced(&self, maybe_id: Option<usize>, black: i32) -> bool {",
			"            if let Some(id) = maybe_id {",
			"                let diff = if self.nodes[id].color.is_red() { 0 } else { -1 };",
			"                self.node_balanced(self.nodes[id].left, black + diff)",
			"                    && self.node_balanced(self.nodes[id].right, black + diff)",
			"            } else {",
			"                black == 0",
			"            }",
			"        }",
			"",
			"        pub fn contains(&self, key: &K) -> bool {",
			"            self.get(key).is_some()",
			"        }",
			"",
			"        pub fn delete(&mut self, key: &K) {",
			"            if !self.contains(key) {",
			"                return;",
			"            }",
			"",
			"            // if both children of root are black, set root to red",
			"            {",
			"                let root = self.root.unwrap();",
			"                if Self::is_red(self.nodes[root].left, &self.nodes)",
			"                    && Self::is_red(self.nodes[root].right, &self.nodes)",
			"                {",
			"                    self.nodes[root].color = Color::red();",
			"                }",
			"            }",
			"            let DeleteResult { child: root, .. } =",
			"                Self::delete_node(self.root.unwrap(), key, &mut self.nodes);",
			"            self.root = root;",
			"",
			"            if !self.is_empty() {",
			"                self.nodes[self.root.unwrap()].color = Color::black();",
			"            }",
			"            // assert!(self.check());",
			"        }",
			"",
			"        pub fn print(&self)",
			"        where",
			"            K: Debug,",
			"            V: Debug,",
			"        {",
			"            Self::print_node(self.root, 0, &self.nodes);",
			"        }",
			"",
			"        fn print_node(maybe_id: Option<usize>, depth: usize, nodes: &[Node<K, V>])",
			"        where",
			"            K: Debug,",
			"            V: Debug,",
			"        {",
			"            let indent = \"     \".repeat(depth);",
			"            if let Some(id) = maybe_id {",
			"                println!(\"{} {:?}\", indent, nodes[id]);",
			"                Self::print_node(nodes[id].left, depth + 1, nodes);",
			"                Self::print_node(nodes[id].right, depth + 1, nodes);",
			"            } else {",
			"                println!(\"{} None\", indent);",
			"            }",
			"        }",
			"",
			"        fn swap_delete_min(",
			"            mut child: usize,",
			"            parent: usize,",
			"            nodes: &mut Vec<Node<K, V>>,",
			"        ) -> DeleteResult {",
			"            if let Some(left) = nodes[child].left {",
			"                if Self::two_left_black(child, nodes) {",
			"                    child = Self::move_red_left(child, nodes);",
			"                }",
			"                let result = Self::swap_delete_min(left, parent, nodes);",
			"                child = result.translate(child);",
			"                nodes[child].left = result.child;",
			"                child = Self::balance(child, nodes);",
			"                result.set_child(child)",
			"            } else {",
			"                nodes[child].parent = nodes[parent].parent;",
			"                nodes[child].color = nodes[parent].color;",
			"                nodes[child].left = nodes[parent].left;",
			"                nodes[child].right = nodes[parent].right;",
			"                nodes[child].size = nodes[parent].size;",
			"                nodes.swap(child, parent);",
			"                Self::remove(parent, nodes)",
			"            }",
			"        }",
			"",
			"        fn two_left_black(id: usize, nodes: &[Node<K, V>]) -> bool {",
			"            let left = nodes[id].left;",
			"            !Self::is_red(left, nodes) && !Self::is_red(nodes[left.unwrap()].left, nodes)",
			"        }",
			"",
			"        fn delete_node(mut id: usize, key: &K, nodes: &mut Vec<Node<K, V>>) -> DeleteResult {",
			"            let result: DeleteResult;",
			"",
			"            if key < &nodes[id].key {",
			"                if Self::two_left_black(id, nodes) {",
			"                    id = Self::move_red_left(id, nodes);",
			"                }",
			"                result = Self::delete_node(nodes[id].left.unwrap(), key, nodes);",
			"                id = result.translate(id);",
			"                nodes[id].left = result.child;",
			"            } else {",
			"                if Self::is_red(nodes[id].left, nodes) {",
			"                    id = Self::rotate_right(id, nodes);",
			"                }",
			"                if key.cmp(&nodes[id].key) == Ordering::Equal && nodes[id].right.is_none() {",
			"                    // TODO: Remove from vector!",
			"                    // nodes.remove(id);",
			"                    return Self::remove(id, nodes);",
			"                }",
			"                // By now we've already proven that Node(id).right is Some.",
			"                // Therefore we are safe to unwrap Node(id).right.",
			"                let right = nodes[id].right;",
			"                if !Self::is_red(right, nodes) && !Self::is_red(nodes[right.unwrap()].left, nodes) {",
			"                    id = Self::move_red_right(id, nodes);",
			"                }",
			"                // This is the node to remove.",
			"                // We'll replace its values with those from the minimum",
			"                // key to the right (the next greatest key from this one).",
			"                if key.cmp(&nodes[id].key) == Ordering::Equal {",
			"                    result = Self::swap_delete_min(nodes[id].right.unwrap(), id, nodes);",
			"                } else {",
			"                    result = Self::delete_node(nodes[id].right.unwrap(), key, nodes);",
			"                }",
			"                id = result.translate(id);",
			"                nodes[id].right = result.child;",
			"            }",
			"            result.set_child(Self::balance(id, nodes))",
			"        }",
			"",
			"        fn balance(mut id: usize, nodes: &mut Vec<Node<K, V>>) -> usize {",
			"            if Self::is_red(nodes[id].right, nodes) {",
			"                id = Self::rotate_left(id, nodes);",
			"            }",
			"            let left = nodes[id].left;",
			"            if Self::is_red(left, nodes) && Self::is_red(nodes[left.unwrap()].left, nodes) {",
			"                id = Self::rotate_right(id, nodes);",
			"            }",
			"            nodes[id].size =",
			"                1 + Self::size(nodes[id].left, nodes) + Self::size(nodes[id].right, nodes);",
			"            Self::maybe_flip(id, nodes);",
			"            id",
			"        }",
			"",
			"        fn maybe_flip(id: usize, nodes: &mut Vec<Node<K, V>>) {",
			"            if let Some(left) = nodes[id].left {",
			"                if let Some(right) = nodes[id].right {",
			"                    if nodes[left].color.is_red() && nodes[right].color.is_red() {",
			"                        Self::flip_colors(id, left, right, nodes);",
			"                    }",
			"                }",
			"            }",
			"        }",
			"",
			"        /// This only happens when node `id` has two consecutive black left children.",
			"        /// Black color only happens on the left when the right is present.",
			"        /// I don't quite understand why we can assume that node `id` is red.",
			"        fn move_red_left(mut id: usize, nodes: &mut Vec<Node<K, V>>) -> usize {",
			"            Self::flip_colors(id, nodes[id].left.unwrap(), nodes[id].right.unwrap(), nodes);",
			"            if Self::is_red(nodes[nodes[id].right.unwrap()].left, nodes) {",
			"                nodes[id].right = Some(Self::rotate_right(nodes[id].right.unwrap(), nodes));",
			"                id = Self::rotate_left(id, nodes);",
			"                Self::flip_colors(id, nodes[id].left.unwrap(), nodes[id].right.unwrap(), nodes);",
			"            }",
			"            id",
			"        }",
			"",
			"        fn move_red_right(mut id: usize, nodes: &mut Vec<Node<K, V>>) -> usize {",
			"            let left = nodes[id].left.unwrap();",
			"            Self::flip_colors(id, left, nodes[id].right.unwrap(), nodes);",
			"            if Self::is_red(nodes[left].left, nodes) {",
			"                id = Self::rotate_right(id, nodes);",
			"                Self::flip_colors(id, nodes[id].left.unwrap(), nodes[id].right.unwrap(), nodes);",
			"            }",
			"            id",
			"        }",
			"",
			"        fn is_red(maybe_id: Option<usize>, nodes: &[Node<K, V>]) -> bool {",
			"            maybe_id.is_some() && nodes[maybe_id.unwrap()].color.is_red()",
			"        }",
			"",
			"        fn min(mut id: usize, nodes: &[Node<K, V>]) -> usize {",
			"            while let Some(left) = nodes[id].left {",
			"                id = left;",
			"            }",
			"            id",
			"        }",
			"",
			"        fn put(",
			"            maybe_id: Option<usize>,",
			"            parent: Option<usize>,",
			"            key: K,",
			"            value: V,",
			"            nodes: &mut Vec<Node<K, V>>,",
			"        ) -> Option<usize> {",
			"            if let Some(mut id) = maybe_id {",
			"                let cmp = key.cmp(&nodes[id].key);",
			"                match cmp {",
			"                    Ordering::Less => {",
			"                        nodes[id].left = Self::put(nodes[id].left, Some(id), key, value, nodes);",
			"                    }",
			"                    Ordering::Greater => {",
			"                        nodes[id].right = Self::put(nodes[id].right, Some(id), key, value, nodes);",
			"                    }",
			"                    Ordering::Equal => {",
			"                        nodes[id].value = value;",
			"                    }",
			"                }",
			"                nodes[id].size =",
			"                    Self::size(nodes[id].left, nodes) + Self::size(nodes[id].right, nodes) + 1;",
			"",
			"                if Self::is_red(nodes[id].right, nodes) && !Self::is_red(nodes[id].left, nodes) {",
			"                    id = Self::rotate_left(id, nodes);",
			"                }",
			"",
			"                if Self::is_red(nodes[id].left, nodes)",
			"                    && Self::is_red(nodes[nodes[id].left.unwrap()].left, nodes)",
			"                {",
			"                    id = Self::rotate_right(id, nodes);",
			"                }",
			"",
			"                if Self::is_red(nodes[id].left, nodes) && Self::is_red(nodes[id].right, nodes) {",
			"                    Self::flip_colors(id, nodes[id].left.unwrap(), nodes[id].right.unwrap(), nodes);",
			"                }",
			"",
			"                Some(id)",
			"            } else {",
			"                let the_id = nodes.len();",
			"                nodes.push(Node {",
			"                    key,",
			"                    value,",
			"                    parent,",
			"                    size: 1,",
			"                    left: None,",
			"                    right: None,",
			"                    color: Color::red(),",
			"                });",
			"                Some(the_id)",
			"            }",
			"        }",
			"",
			"        fn flip_colors(base: usize, left: usize, right: usize, nodes: &mut Vec<Node<K, V>>) {",
			"            nodes[base].color.flip();",
			"            nodes[left].color.flip();",
			"            nodes[right].color.flip();",
			"        }",
			"",
			"        fn rotate_left(h: usize, nodes: &mut Vec<Node<K, V>>) -> usize {",
			"            let x = nodes[h].right.unwrap();",
			"",
			"            nodes[h].right = nodes[x].left;",
			"            nodes[x].left = Some(h);",
			"            nodes[x].color = nodes[h].color;",
			"            nodes[h].color = Color::red();",
			"",
			"            // fix parents",
			"            nodes[x].parent = nodes[h].parent;",
			"            nodes[h].parent = Some(x);",
			"            if let Some(right) = nodes[h].right {",
			"                nodes[right].parent = Some(h);",
			"            }",
			"",
			"            // fix size",
			"            nodes[x].size = nodes[h].size;",
			"            nodes[h].size =",
			"                Self::size(nodes[h].left, nodes) + Self::size(nodes[h].right, nodes) + 1;",
			"",
			"            x",
			"        }",
			"",
			"        fn remove(id: usize, nodes: &mut Vec<Node<K, V>>) -> DeleteResult {",
			"            let other = nodes.len() - 1;",
			"            nodes.swap(id, other);",
			"            if let Some(parent) = nodes[id].parent {",
			"                let parent_node = nodes.get_mut(parent).unwrap();",
			"                if parent_node.left.is_some() && parent_node.left.unwrap() == other {",
			"                    parent_node.left = Some(id);",
			"                } else {",
			"                    parent_node.right = Some(id);",
			"                }",
			"            }",
			"            nodes.pop();",
			"            DeleteResult {",
			"                child: None,",
			"                moved_node: other,",
			"                moved_node_new_id: id,",
			"            }",
			"        }",
			"",
			"        fn rotate_right(h: usize, nodes: &mut Vec<Node<K, V>>) -> usize {",
			"            let x = nodes[h].left.unwrap();",
			"",
			"            nodes[h].left = nodes[x].right;",
			"            nodes[x].right = Some(h);",
			"            nodes[x].color = nodes[h].color;",
			"            nodes[h].color = Color::red();",
			"",
			"            // fix parents",
			"            nodes[x].parent = nodes[h].parent;",
			"            nodes[h].parent = Some(x);",
			"            if let Some(left) = nodes[h].left {",
			"                nodes[left].parent = Some(h);",
			"            }",
			"",
			"            // fix size",
			"            nodes[x].size = nodes[h].size;",
			"            nodes[h].size =",
			"                Self::size(nodes[h].left, nodes) + Self::size(nodes[h].right, nodes) + 1;",
			"",
			"            x",
			"        }",
			"",
			"        fn size(maybe_id: Option<usize>, nodes: &[Node<K, V>]) -> usize {",
			"            if let Some(id) = maybe_id {",
			"                nodes[id].size",
			"            } else {",
			"                0",
			"            }",
			"        }",
			"",
			"        /**",
			"         * Debug Functions",
			"         */",
			"",
			"        pub fn check(&self) -> bool",
			"        where",
			"            K: Debug,",
			"            V: Debug,",
			"        {",
			"            let mut good = self.is_bst();",
			"            if !good {",
			"                println!(\"Not in symmetric order\");",
			"            }",
			"            if !self.is_size_consistent() {",
			"                println!(\"Subtree counts not consistent\");",
			"                good = false;",
			"            }",
			"            if !self.is_rank_consistent() {",
			"                println!(\"Ranks not consistent\");",
			"                good = false;",
			"            }",
			"            if !self.is_23() {",
			"                println!(\"Not a 2-3 tree\");",
			"                good = false;",
			"            }",
			"            if !self.is_balanced() {",
			"                println!(\"Not balanced\");",
			"                self.print();",
			"                good = false;",
			"            }",
			"            good",
			"        }",
			"",
			"        pub fn is_rank_consistent(&self) -> bool",
			"        where",
			"            K: Debug,",
			"            V: Debug,",
			"        {",
			"            for i in 0..self.len() {",
			"                if i != self.rank(self.select(i)) {",
			"                    println!(",
			"                        \"Rank {} expected key {:?} but got {}\",",
			"                        i,",
			"                        self.select(i),",
			"                        self.rank(self.select(i))",
			"                    );",
			"                    self.print();",
			"                    return false;",
			"                }",
			"            }",
			"            for key in self.keys().iter() {",
			"                if *key != self.select(self.rank(*key)) {",
			"                    println!(",
			"                        \"Key {:?} has rank {} which evaluates to key {:?}\",",
			"                        *key,",
			"                        self.rank(*key),",
			"                        self.select(self.rank(*key))",
			"                    );",
			"                    return false;",
			"                }",
			"            }",
			"            true",
			"        }",
			"",
			"        pub fn keys(&self) -> Vec<&K> {",
			"            self.nodes.iter().map(|node| &node.key).collect::<Vec<&K>>()",
			"        }",
			"",
			"        pub fn is_23(&self) -> bool {",
			"            self.is_node_23(self.root)",
			"        }",
			"",
			"        fn is_node_23(&self, maybe_id: Option<usize>) -> bool {",
			"            if let Some(id) = maybe_id {",
			"                if Self::is_red(self.nodes[id].right, &self.nodes) {",
			"                    return false;",
			"                }",
			"                if id != self.root.unwrap()",
			"                    && self.nodes[id].color.is_red()",
			"                    && Self::is_red(self.nodes[id].left, &self.nodes)",
			"                {",
			"                    return false;",
			"                }",
			"                self.is_node_23(self.nodes[id].left) && self.is_node_23(self.nodes[id].right)",
			"            } else {",
			"                true",
			"            }",
			"        }",
			"",
			"        /// Number of keys k: k < key",
			"        pub fn rank(&self, key: &K) -> usize {",
			"            self.rank_in_subtree(key, self.root)",
			"        }",
			"",
			"        fn rank_in_subtree(&self, key: &K, maybe_id: Option<usize>) -> usize {",
			"            if let Some(id) = maybe_id {",
			"                match key.cmp(&self.nodes[id].key) {",
			"                    Ordering::Less => self.rank_in_subtree(key, self.nodes[id].left),",
			"                    Ordering::Greater => {",
			"                        1 + Self::size(self.nodes[id].left, &self.nodes)",
			"                            + self.rank_in_subtree(key, self.nodes[id].right)",
			"                    }",
			"                    Ordering::Equal => Self::size(self.nodes[id].left, &self.nodes),",
			"                }",
			"            } else {",
			"                0",
			"            }",
			"        }",
			"",
			"        /// tree[rank] (if `tree` was a linear datastructure)",
			"        pub fn select(&self, rank: usize) -> &K {",
			"            if rank >= self.len() {",
			"                panic!(\"Asked for rank greater than size of tree\");",
			"            }",
			"            &self.nodes[self.select_from_node(rank, self.root.unwrap())].key",
			"        }",
			"",
			"        fn select_from_node(&self, rank: usize, id: usize) -> usize {",
			"            let t = Self::size(self.nodes[id].left, &self.nodes);",
			"            match t.cmp(&rank) {",
			"                Ordering::Greater => self.select_from_node(rank, self.nodes[id].left.unwrap()),",
			"                Ordering::Less => {",
			"                    self.select_from_node(rank - t - 1, self.nodes[id].right.unwrap())",
			"                }",
			"                Ordering::Equal => id,",
			"            }",
			"        }",
			"",
			"        pub fn is_size_consistent(&self) -> bool {",
			"            self.is_node_size_consistent(self.root)",
			"        }",
			"",
			"        fn is_node_size_consistent(&self, maybe_id: Option<usize>) -> bool {",
			"            if let Some(id) = maybe_id {",
			"                let node = &self.nodes[id];",
			"                if node.size",
			"                    != 1 + Self::size(node.left, &self.nodes) + Self::size(node.right, &self.nodes)",
			"                {",
			"                    return false;",
			"                }",
			"                self.is_node_size_consistent(node.left) && self.is_node_size_consistent(node.right)",
			"            } else {",
			"                true",
			"            }",
			"        }",
			"",
			"        pub fn is_bst(&self) -> bool {",
			"            self.is_node_bst(self.root, None, None)",
			"        }",
			"",
			"        fn is_node_bst(",
			"            &self,",
			"            maybe_id: Option<usize>,",
			"            maybe_min: Option<&K>,",
			"            maybe_max: Option<&K>,",
			"        ) -> bool {",
			"            if let Some(id) = maybe_id {",
			"                let key = &self.nodes[id].key;",
			"                if let Some(min) = maybe_min {",
			"                    if key <= min {",
			"                        return false;",
			"                    }",
			"                }",
			"                if let Some(max) = maybe_max {",
			"                    if key >= max {",
			"                        return false;",
			"                    }",
			"                }",
			"                self.is_node_bst(self.nodes[id].left, maybe_min, Some(key))",
			"                    && self.is_node_bst(self.nodes[id].right, Some(key), maybe_max)",
			"            } else {",
			"                true",
			"            }",
			"        }",
			"",
			"        fn find_next(&self, mut from: usize) -> Option<usize> {",
			"            // If there's a right from here, find the min value from there.",
			"            // Don't care about current left.",
			"            // Go to parent.",
			"            // While parent key is less than my key,",
			"            //   that means that I was on the right and I should go up again.",
			"            //",
			"            // If there is a right from here, that means greater than the current",
			"            // key but not necessarily greater than the _from_ key.",
			"            // Only traverse up the right branch if right key < mine.",
			"            let the_key = &self.nodes[from].key;",
			"            if let Some(right) = self.nodes[from].right {",
			"                from = Self::min(right, &self.nodes);",
			"            } else {",
			"                while *the_key >= self.nodes[from].key {",
			"                    if let Some(parent) = self.nodes[from].parent {",
			"                        from = parent;",
			"                    } else {",
			"                        return None;",
			"                    }",
			"                }",
			"                if let Some(right) = self.nodes[from].right {",
			"                    if self.nodes[right].key < *the_key {",
			"                        from = Self::min(right, &self.nodes);",
			"                    }",
			"                }",
			"            }",
			"",
			"            Some(from)",
			"        }",
			"    }",
			"",
			"    impl<K, V> Default for RBTree<K, V>",
			"    where",
			"        K: Ord,",
			"    {",
			"        fn default() -> Self {",
			"            Self {",
			"                root: None,",
			"                nodes: vec![],",
			"            }",
			"        }",
			"    }",
			"    pub struct TreeIteratorRef<'a, K, V>",
			"    where",
			"        K: Ord,",
			"    {",
			"        next_node: Option<usize>,",
			"        tree: &'a RBTree<K, V>,",
			"    }",
			"    impl<K, V> RBTree<K, V>",
			"    where",
			"        K: Ord,",
			"    {",
			"        pub fn iter(&self) -> TreeIteratorRef<'_, K, V> {",
			"            let next_node = if self.is_empty() {",
			"                None",
			"            } else {",
			"                Some(RBTree::min(self.root.unwrap(), &self.nodes))",
			"            };",
			"",
			"            TreeIteratorRef {",
			"                next_node,",
			"                tree: self,",
			"            }",
			"        }",
			"    }",
			"    impl<'a, K: Ord, V> IntoIterator for &'a RBTree<K, V> {",
			"        type Item = (&'a K, &'a V);",
			"        type IntoIter = TreeIteratorRef<'a, K, V>;",
			"",
			"        fn into_iter(self) -> Self::IntoIter {",
			"            self.iter()",
			"        }",
			"    }",
			"    impl<'a, K, V> Iterator for TreeIteratorRef<'a, K, V>",
			"    where",
			"        K: Ord,",
			"    {",
			"        type Item = (&'a K, &'a V);",
			"",
			"        fn next(&mut self) -> Option<Self::Item> {",
			"            if let Some(current_id) = self.next_node {",
			"                // find next",
			"                self.next_node = self.tree.find_next(current_id);",
			"",
			"                let node = &self.tree.nodes[current_id];",
			"                Some((&node.key, &node.value))",
			"            } else {",
			"                None",
			"            }",
			"        }",
			"    }",
			"    /// Safety: Must take a mutable reference to build this",
			"    pub struct TreeIteratorMut<'a, K, V>",
			"    where",
			"        K: Ord,",
			"    {",
			"        next_node: Option<usize>,",
			"        tree: &'a mut RBTree<K, V>,",
			"    }",
			"    impl<K, V> RBTree<K, V>",
			"    where",
			"        K: Ord,",
			"    {",
			"        pub fn iter_mut(&mut self) -> TreeIteratorMut<'_, K, V> {",
			"            let next_node = if self.is_empty() {",
			"                None",
			"            } else {",
			"                Some(RBTree::min(self.root.unwrap(), &self.nodes))",
			"            };",
			"",
			"            TreeIteratorMut {",
			"                next_node,",
			"                tree: self,",
			"            }",
			"        }",
			"    }",
			"    impl<'a, K: Ord, V> IntoIterator for &'a mut RBTree<K, V> {",
			"        type Item = (&'a K, &'a mut V);",
			"        type IntoIter = TreeIteratorMut<'a, K, V>;",
			"",
			"        fn into_iter(self) -> Self::IntoIter {",
			"            self.iter_mut()",
			"        }",
			"    }",
			"    impl<'a, K, V> Iterator for TreeIteratorMut<'a, K, V>",
			"    where",
			"        K: Ord,",
			"    {",
			"        type Item = (&'a K, &'a mut V);",
			"",
			"        fn next(&mut self) -> Option<Self::Item> {",
			"            if let Some(current_id) = self.next_node {",
			"                // find next",
			"                self.next_node = self.tree.find_next(current_id);",
			"",
			"                let tree: &'a mut RBTree<K, V> =",
			"                    unsafe { std::mem::transmute(&mut *std::ptr::from_mut(self.tree)) };",
			"                let node = &mut tree.nodes[current_id];",
			"                Some((&node.key, &mut node.value))",
			"            } else {",
			"                None",
			"            }",
			"        }",
			"    }",
			"    impl<K: Ord, V> IntoIterator for RBTree<K, V> {",
			"        type Item = (K, V);",
			"        type IntoIter = std::vec::IntoIter<(K, V)>;",
			"",
			"        fn into_iter(mut self) -> Self::IntoIter {",
			"            let mut cur = if self.is_empty() {",
			"                None",
			"            } else {",
			"                Some(RBTree::min(self.root.unwrap(), &self.nodes))",
			"            };",
			"            let mut order = vec![];",
			"            while let Some(c) = cur {",
			"                order.push(c);",
			"                cur = self.find_next(c);",
			"            }",
			"            let mut rev = vec![0; self.len()];",
			"            for i in 0..self.len() {",
			"                rev[order[i]] = i;",
			"            }",
			"            let mut res = ManuallyDrop::new(Vec::with_capacity(self.len()));",
			"            unsafe {",
			"                res.set_len(self.len());",
			"            }",
			"            for i in (0..self.len()).rev() {",
			"                let Node {",
			"                    key: k, value: v, ..",
			"                } = self.nodes.pop().unwrap();",
			"",
			"                res[rev[i]] = (k, v);",
			"            }",
			"            ManuallyDrop::into_inner(res).into_iter()",
			"        }",
			"    }",
			"}"
		]
	},
	"segment_tree": {
		"scope": "rust",
		"prefix": "segment_tree",
		"body": [
			"$0",
			"pub struct SegmentTree {",
			"    pub tree: Vec<SegmentTreeType>,",
			"}",
			"impl SegmentTree {",
			"    pub fn new(input: &[SegmentTreeType]) -> Self {",
			"        let n = input.len().next_power_of_two();",
			"        let mut tree = vec![DEFAULT_SEGMENT_TREE_TYPE; 2 * n - 1];",
			"        tree[n - 1..n - 1 + input.len()].clone_from_slice(input);",
			"        for i in (0..n - 1).rev() {",
			"            tree[i] = transform(&tree[2 * i + 1], &tree[2 * i + 2]);",
			"        }",
			"        Self { tree }",
			"    }",
			"",
			"    /// Query the segment tree for the range [l, r).",
			"    pub fn query(&self, l: usize, r: usize) -> Option<SegmentTreeType> {",
			"        self.query_rec(0, 0, (self.tree.len() + 1) >> 1, l, r)",
			"    }",
			"",
			"    fn query_rec(",
			"        &self,",
			"        i: usize,",
			"        il: usize,",
			"        ir: usize,",
			"        l: usize,",
			"        r: usize,",
			"    ) -> Option<SegmentTreeType> {",
			"        if ir <= l || r <= il {",
			"            return None;",
			"        }",
			"        if l <= il && ir <= r {",
			"            return Some(self.tree[i].clone());",
			"        }",
			"        let m = (il + ir) >> 1;",
			"        let left = self.query_rec(2 * i + 1, il, m, l, r);",
			"        let right = self.query_rec(2 * i + 2, m, ir, l, r);",
			"        match (left, right) {",
			"            (Some(left), Some(right)) => Some(transform(&left, &right)),",
			"            (Some(left), None) => Some(left),",
			"            (None, Some(right)) => Some(right),",
			"            (None, None) => None,",
			"        }",
			"    }",
			"",
			"    pub fn update(&mut self, i: usize, v: SegmentTreeType) {",
			"        let n = (self.tree.len() + 1) / 2;",
			"        let mut i = i + n - 1;",
			"        self.tree[i] = v;",
			"        while i > 0 {",
			"            i = (i - 1) / 2;",
			"            self.tree[i] = transform(&self.tree[2 * i + 1], &self.tree[2 * i + 2]);",
			"        }",
			"    }",
			"}",
			"",
			"pub type SegmentTreeType = compile_error!(\"SegmenTreeType\");",
			"const DEFAULT_SEGMENT_TREE_TYPE: SegmentTreeType = 0;",
			"",
			"pub fn transform(lhs: &SegmentTreeType, rhs: &SegmentTreeType) -> SegmentTreeType {",
			"    todo!()",
			"}"
		]
	},
	"articulation_bridges": {
		"scope": "rust",
		"prefix": "articulation_bridges",
		"body": [
			"$0",
			"let mut dfsin = vec![0; n];",
			"let mut low = vec![0; n];",
			"let mut subtree_size = vec![1; n];",
			"let mut is_art = vec![false; n];",
			"fn dfs(",
			"    u: U,",
			"    edges: &Vec<Vec<U>>,",
			"    dfsin: &mut Vec<U>,",
			"    low: &mut Vec<U>,",
			"    subtree_size: &mut Vec<U>,",
			"    is_art: &mut Vec<bool>,",
			"    tt: &mut HashSet<(U, U)>,",
			"    bridges: &mut Vec<(U, U)>,",
			"    t: &mut U,",
			") -> U {",
			"    *t += 1;",
			"    dfsin[u] = *t;",
			"    low[u] = *t;",
			"    for v in &edges[u] {",
			"        if dfsin[*v] == 0 {",
			"            tt.insert((*v.min(&u), *v.max(&u)));",
			"            let val = dfs(*v, edges, dfsin, low, subtree_size, is_art, tt, bridges, t);",
			"            subtree_size[u] += subtree_size[*v];",
			"            if val >= dfsin[u] {",
			"                is_art[u] = true;",
			"            }",
			"            low[u] = low[u].min(val);",
			"        } else if dfsin[*v] != 0 && !tt.contains(&(*v.min(&u), *v.max(&u))) {",
			"            low[u] = low[u].min(dfsin[*v]);",
			"        }",
			"    }",
			"    low[u]",
			"}",
			"let mut tt = HashSet::new();",
			"let mut bridges = vec![];",
			"dfs(",
			"    0,",
			"    &graph,",
			"    &mut dfsin,",
			"    &mut low,",
			"    &mut subtree_size,",
			"    &mut is_art,",
			"    &mut tt,",
			"    &mut bridges,",
			"    &mut 0,",
			");",
			"is_art[0] = tt.into_iter().filter(|x| x.0 == 0).count() >= 2;",
			"for (u, v) in edges {",
			"    if low[u] > dfsin[v] || low[v] > dfsin[u] {",
			"        bridges.push((u, v));",
			"    }",
			"}"
		]
	},
	"maximum_weight_bipartite_matching": {
		"scope": "rust",
		"prefix": "maximum_weight_bipartite_matching",
		"body": [
			"$0",
			"// for minimal weighted matching simply invert the edge costs,",
			"// but note that an empty matching (e.g. if all edges negative) has a weight of `0`",
			"#[derive(Debug, Clone, PartialEq, Eq)]",
			"pub struct MaximumWeightBipartiteMatching {",
			"    graph: Vec<Vec<(usize, isize)>>,",
			"    alen: usize,",
			"}",
			"impl MaximumWeightBipartiteMatching {",
			"    pub fn new(mut a: Vec<Vec<(usize, isize)>>, blen: usize) -> Self {",
			"        for v in &mut a {",
			"            v.sort_unstable();",
			"        }",
			"        let alen = a.len();",
			"        let mut b = vec![vec![]; blen];",
			"        for (u, connected_to) in a.iter_mut().enumerate() {",
			"            for (v, c) in connected_to.iter_mut() {",
			"                b[*v].push((u + 1, isize::MAX));",
			"                *v += alen + 1;",
			"                *c = c.saturating_neg();",
			"            }",
			"            connected_to.insert(0, (0, isize::MAX));",
			"        }",
			"        for u in 0..blen {",
			"            b[u].push((alen + blen + 1, 0));",
			"        }",
			"        a.insert(0, (1..=alen).map(|x| (x, 0)).cv());",
			"        a.extend(b);",
			"        a.push((alen + 1..alen + 1 + blen).map(|x| (x, isize::MAX)).cv());",
			"        Self { graph: a, alen }",
			"    }",
			"",
			"    pub fn calculate(mut self) -> Vec<(usize, usize, isize)> {",
			"        let mut matching = HashSet::new();",
			"        while let Some(augment) = self.bellman_ford() {",
			"            for i in 1..augment.len() {",
			"                let (u, v) = (augment[i - 1], augment[i]);",
			"                let vi = self.graph[u].binary_search_by_key(&v, |x| x.0).unwrap();",
			"                let ui = self.graph[v].binary_search_by_key(&u, |x| x.0).unwrap();",
			"                self.graph[v][ui].1 = -self.graph[u][vi].1;",
			"                self.graph[u][vi].1 = isize::MAX;",
			"                if u < v {",
			"                    assert!(matching.insert((u, v, -self.graph[v][ui].1)));",
			"                } else {",
			"                    assert!(matching.remove(&(v, u, self.graph[v][ui].1)));",
			"                }",
			"            }",
			"        }",
			"        matching",
			"            .into_iter()",
			"            .filter(|&(u, v, _)| u != 0 && v != self.graph.len() - 1)",
			"            .map(|(u, v, c)| (u - 1, v - 1 - self.alen, c.saturating_neg()))",
			"            .cv()",
			"    }",
			"",
			"    fn bellman_ford(&self) -> Option<Vec<usize>> {",
			"        let mut dist = vec![isize::MAX; self.graph.len()];",
			"        dist[0] = 0;",
			"        let mut parent = vec![usize::MAX; self.graph.len()];",
			"",
			"        for j in 0..dist.len() {",
			"            let mut changed = false;",
			"            for u in 0..self.graph.len() {",
			"                if dist[u] == isize::MAX {",
			"                    continue;",
			"                }",
			"                for (v, c) in &self.graph[u] {",
			"                    if *c != isize::MAX {",
			"                        if dist[u] + c < dist[*v] {",
			"                            dist[*v] = dist[u] + c;",
			"                            parent[*v] = u;",
			"                            changed = true;",
			"                        }",
			"                    }",
			"                }",
			"            }",
			"            if !changed {",
			"                break;",
			"            }",
			"            if j + 1 == dist.len() {",
			"                panic!(\"Negative cycle!\");",
			"            }",
			"        }",
			"        if dist.l() >= 0 {",
			"            return None;",
			"        }",
			"        let mut cur = dist.len() - 1;",
			"        let mut path = vec![cur];",
			"        while parent[cur] != usize::MAX {",
			"            path.push(parent[cur]);",
			"            cur = parent[cur];",
			"        }",
			"        path.reverse();",
			"        Some(path)",
			"    }",
			"}"
		]
	},
	"lazy_segment_tree": {
		"scope": "rust",
		"prefix": "lazy_segment_tree",
		"body": [
			"$0",
			"pub struct LazySegmentTree {",
			"    pub n: usize,",
			"    pub tree: Vec<SegmentTreeType>,",
			"    lazy: Vec<Option<UpdateType>>,",
			"}",
			"impl LazySegmentTree {",
			"    pub fn new(input: &[SegmentTreeType]) -> Self {",
			"        let n = input.len().next_power_of_two();",
			"        let mut tree = vec![DEFAULT_SEGMENT_TREE_TYPE; 2 * n - 1];",
			"        tree[n - 1..n - 1 + input.len()].clone_from_slice(input);",
			"        for i in (0..n - 1).rev() {",
			"            tree[i] = transform(&tree[2 * i + 1], &tree[2 * i + 2]);",
			"        }",
			"        Self {",
			"            tree,",
			"",
			"            lazy: vec![None; n - 1],",
			"            n,",
			"        }",
			"    }",
			"",
			"    /// Query the segment tree for the range [l, r) and update lazy stuff.",
			"    pub fn query(&mut self, l: usize, r: usize) -> Option<SegmentTreeType> {",
			"        self.query_rec(0, 0, self.n, l, r)",
			"    }",
			"",
			"    fn push_down(&mut self, i: usize) {",
			"        if let Some(v) = self.lazy[i].take() {",
			"            for j in 1..=2 {",
			"                let idx = (i << 1) + j;",
			"                if idx < self.tree.len() {",
			"                    self.tree[idx] = update(&self.tree[idx], &v, self.len_at(idx));",
			"                    self.add_lazy(idx, &v);",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"    fn query_rec(",
			"        &mut self,",
			"        i: usize,",
			"        il: usize,",
			"        ir: usize,",
			"        l: usize,",
			"        r: usize,",
			"    ) -> Option<SegmentTreeType> {",
			"        if ir <= l || r <= il {",
			"            return None;",
			"        }",
			"        if l <= il && ir <= r {",
			"            return Some(self.tree[i].clone());",
			"        }",
			"",
			"        self.push_down(i);",
			"",
			"        let m = (il + ir) >> 1;",
			"        let left = self.query_rec(2 * i + 1, il, m, l, r);",
			"        let right = self.query_rec(2 * i + 2, m, ir, l, r);",
			"        match (left, right) {",
			"            (Some(l), Some(r)) => Some(transform(&l, &r)),",
			"            (Some(l), None) => Some(l),",
			"            (None, Some(r)) => Some(r),",
			"            (None, None) => None,",
			"        }",
			"    }",
			"",
			"    fn add_lazy(&mut self, i: usize, v: &UpdateType) {",
			"        if i < self.lazy.len() {",
			"            if let Some(l) = self.lazy[i].take() {",
			"                self.lazy[i] = Some(todo!(\"aggregate\"));",
			"            } else {",
			"                self.lazy[i] = Some(v.clone());",
			"            }",
			"        }",
			"    }",
			"",
			"    /// Lazily update all values in [l; r) to v",
			"    pub fn update(&mut self, l: usize, r: usize, v: UpdateType) {",
			"        self.update_rec(0, 0, self.n, l, r, v);",
			"    }",
			"",
			"    fn update_rec(&mut self, i: usize, il: usize, ir: usize, l: usize, r: usize, v: UpdateType) {",
			"        if ir <= l || r <= il {",
			"            return;",
			"        }",
			"        if l <= il && ir <= r {",
			"            self.tree[i] = update(&self.tree[i], &v, self.len_at(i));",
			"            self.add_lazy(i, &v);",
			"            if i != 0 {",
			"                let mut i = i;",
			"                while i > 0 {",
			"                    i = (i - 1) >> 1;",
			"                    self.tree[i] = transform(&self.tree[(i << 1) + 1], &self.tree[(i << 1) + 2]);",
			"                }",
			"            }",
			"            return;",
			"        }",
			"",
			"        self.push_down(i);",
			"",
			"        let m = (il + ir) >> 1;",
			"        self.update_rec(2 * i + 1, il, m, l, r, v.clone());",
			"        self.update_rec(2 * i + 2, m, ir, l, r, v.clone());",
			"    }",
			"",
			"    fn len_at(&self, i: usize) -> usize {",
			"        self.n >> (i + 1).ilog2()",
			"    }",
			"}",
			"",
			"pub type SegmentTreeType = compile_error!(\"TagType\");",
			"pub type UpdateType = compile_error!(\"UpdateType\");",
			"const DEFAULT_SEGMENT_TREE_TYPE: SegmentTreeType = 0;",
			"",
			"pub fn transform(lhs: &SegmentTreeType, rhs: &SegmentTreeType) -> SegmentTreeType {",
			"    todo!()",
			"}",
			"pub fn update(old: &SegmentTreeType, update: &UpdateType, segment_len: usize) -> SegmentTreeType {",
			"    todo!()",
			"}"
		]
	},
	"interpolate_polynomial": {
		"scope": "rust",
		"prefix": "interpolate_polynomial",
		"body": [
			"$0",
			"fn mul_add_row(mut row_a: [N; 11], row_b: [N; 11], f: N) -> [N; 11] {",
			"    for i in 0..11 {",
			"        row_a[i] += row_b[i] * f;",
			"    }",
			"    row_a",
			"}",
			"",
			"fn solve(mut matrix: [[N; 11]; 11], mut b: [N; 11]) -> [N; 11] {",
			"    for i in 0..11 {",
			"        let f = matrix[i][i];",
			"        for j in 0..11 {",
			"            matrix[i][j] /= f;",
			"        }",
			"        b[i] /= f;",
			"        for j in i + 1..11 {",
			"            b[j] -= b[i] * matrix[j][i];",
			"            matrix[j] = mul_add_row(matrix[j], matrix[i], -matrix[j][i]);",
			"        }",
			"    }",
			"    for i in (1..11).rev() {",
			"        for j in 0..i {",
			"            b[j] -= b[i] * matrix[j][i];",
			"            matrix[j] = mul_add_row(matrix[j], matrix[i], -matrix[j][i]);",
			"        }",
			"    }",
			"    b",
			"}",
			"",
			"fn eval(x: N, coef: &[N; 11]) -> N {",
			"    let mut res = N::ZERO;",
			"    for (i, c) in coef.iter().enumerate() {",
			"        res += x.pow(i) * *c;",
			"    }",
			"    res",
			"}"
		]
	},
	"persistent_segment_tree": {
		"scope": "rust",
		"prefix": "persistent_segment_tree",
		"body": [
			"$0",
			"pub struct PersistentSegmentTree {",
			"    roots: Vec<usize>,",
			"    nodes: Vec<(usize, usize, SegmentTreeType)>,",
			"    n: usize,",
			"}",
			"impl PersistentSegmentTree {",
			"    pub fn build(initial_values: &[SegmentTreeType]) -> Self {",
			"        let n = initial_values.len();",
			"        let mut nodes = vec![];",
			"        let root = Self::build_recursive(0, n, initial_values, &mut nodes);",
			"        let roots = vec![root];",
			"        Self { roots, nodes, n }",
			"    }",
			"    fn build_recursive(",
			"        i: usize,",
			"        j: usize,",
			"        initial_values: &[SegmentTreeType],",
			"        nodes: &mut Vec<(usize, usize, SegmentTreeType)>,",
			"    ) -> usize {",
			"        if j - i == 1 {",
			"            let node = nodes.len();",
			"            nodes.push((usize::MAX, usize::MAX, initial_values[i].clone()));",
			"            node",
			"        } else {",
			"            let m = (i + j) / 2;",
			"            let left = Self::build_recursive(i, m, initial_values, nodes);",
			"            let right = Self::build_recursive(m, j, initial_values, nodes);",
			"            let node = nodes.len();",
			"            nodes.push((left, right, transform(&nodes[left].2, &nodes[right].2)));",
			"            node",
			"        }",
			"    }",
			"",
			"    /// Returns the \"pointer\" to the new root",
			"    pub fn update(&mut self, root: usize, i: usize, value: UpdateType) -> usize {",
			"        let new_root = self.update_recursive(self.roots[root], 0, self.n, i, value);",
			"        self.roots.push(new_root);",
			"        self.roots.len() - 1",
			"    }",
			"",
			"    fn update_recursive(",
			"        &mut self,",
			"        node: usize,",
			"        left: usize,",
			"        right: usize,",
			"        index: usize,",
			"        value: UpdateType,",
			"    ) -> usize {",
			"        if right - left == 1 {",
			"            let new_node = self.nodes.len();",
			"            self.nodes",
			"                .push((usize::MAX, usize::MAX, update(&self.nodes[node].2, &value)));",
			"            new_node",
			"        } else {",
			"            let m = (left + right) / 2;",
			"            let (l, r, _) = &self.nodes[node];",
			"            let mut new_left = *l;",
			"            let mut new_right = *r;",
			"            if index < m {",
			"                new_left = self.update_recursive(*l, left, m, index, value);",
			"            } else {",
			"                new_right = self.update_recursive(*r, m, right, index, value);",
			"            }",
			"            let new_value = transform(&self.nodes[new_left].2, &self.nodes[new_right].2);",
			"            let new_node = self.nodes.len();",
			"            self.nodes.push((new_left, new_right, new_value));",
			"            new_node",
			"        }",
			"    }",
			"    pub fn query(&self, root: usize, i: usize, j: usize) -> SegmentTreeType {",
			"        self.query_recursive(self.roots[root], 0, self.n, i, j)",
			"    }",
			"    fn query_recursive(",
			"        &self,",
			"        node: usize,",
			"        left: usize,",
			"        right: usize,",
			"        i: usize,",
			"        j: usize,",
			"    ) -> SegmentTreeType {",
			"        if i <= left && right <= j {",
			"            self.nodes[node].2.clone()",
			"        } else {",
			"            let m = (left + right) / 2;",
			"            let (left_child, right_child, _) = self.nodes[node];",
			"            if j <= m {",
			"                self.query_recursive(left_child, left, m, i, j)",
			"            } else if m <= i {",
			"                self.query_recursive(right_child, m, right, i, j)",
			"            } else {",
			"                let left_value = self.query_recursive(left_child, left, m, i, j);",
			"                let right_value = self.query_recursive(right_child, m, right, i, j);",
			"                transform(&left_value, &right_value)",
			"            }",
			"        }",
			"    }",
			"}",
			"",
			"pub type SegmentTreeType = compile_error!(\"SegmentTreeType\");",
			"pub type UpdateType = compile_error!(\"UpdateType\");",
			"",
			"pub fn transform(lhs: &SegmentTreeType, rhs: &SegmentTreeType) -> SegmentTreeType {",
			"    todo!()",
			"}",
			"pub fn update(old: &SegmentTreeType, update: &UpdateType) -> SegmentTreeType {",
			"    todo!()",
			"}"
		]
	},
	"fft": {
		"scope": "rust",
		"prefix": "fft",
		"body": [
			"$0",
			"// requires Complex",
			"",
			"// from: https://cp-algorithms.com/algebra/fft.html#improved-implementation-in-place-computation",
			"pub fn fft(a: &mut Vec<Complex>, invert: bool) {",
			"    let n = a.len();",
			"",
			"    let mut j = 0;",
			"    for i in 1..n {",
			"        let mut bit = n >> 1;",
			"        while j & bit != 0 {",
			"            j ^= bit;",
			"            bit >>= 1;",
			"        }",
			"        j ^= bit;",
			"        if i < j {",
			"            a.swap(i, j);",
			"        }",
			"    }",
			"",
			"    let mut len = 2;",
			"    while len <= n {",
			"        let ang = 2. * PI / len as CT * if invert { -1. } else { 1. };",
			"        let (s, c) = sin_cos(ang);",
			"        let wlen = Complex(c, s);",
			"        for i in (0..n).step_by(len) {",
			"            let mut w = Complex::ONE;",
			"            for j in 0..len / 2 {",
			"                let u = a[i + j];",
			"                let v = a[i + j + len / 2] * w;",
			"                a[i + j] = u + v;",
			"                a[i + j + len / 2] = u - v;",
			"                w *= wlen;",
			"            }",
			"        }",
			"",
			"        len <<= 1;",
			"    }",
			"",
			"    if invert {",
			"        for x in a {",
			"            *x /= n as CT;",
			"        }",
			"    }",
			"}",
			"",
			"pub fn multiply(a: &Vec<isize>, b: &Vec<isize>) -> Vec<isize> {",
			"    let mut result = multiply_complex(",
			"        &a.iter().map(|x| Complex(*x as CT, 0.)).cv(),",
			"        &b.iter().map(|x| Complex(*x as CT, 0.)).cv(),",
			"    )",
			"    .into_iter()",
			"    .map(|x| x.0.round() as I)",
			"    .cv();",
			"    while result.len() > 1 && result.last().unwrap() == &0 {",
			"        result.pop().unwrap();",
			"    }",
			"    result",
			"}",
			"",
			"pub fn multiply_complex(a: &Vec<Complex>, b: &Vec<Complex>) -> Vec<Complex> {",
			"    let mut fa = a.clone();",
			"    let mut fb = b.clone();",
			"    let n = (a.len() + b.len()).next_power_of_two();",
			"",
			"    fa.resize(n, Complex::ZERO);",
			"    fb.resize(n, Complex::ZERO);",
			"",
			"    fft(&mut fa, false);",
			"    fft(&mut fb, false);",
			"    for (fai, fbi) in fa.iter_mut().zip(fb) {",
			"        *fai *= fbi;",
			"    }",
			"    fft(&mut fa, true);",
			"",
			"    fa",
			"}"
		]
	},
	"ntt": {
		"scope": "rust",
		"prefix": "ntt",
		"body": [
			"$0",
			"// require mod_int",
			"",
			"// to find primitive roots: https://www.wolframalpha.com/input/?i=PrimitiveRoots%5B%5B%2F%2Fnumber%3A998244353%2F%2F%5D%5D",
			"const MOD: usize = 998244353; // 2^23 * 7 * 17 + 1",
			"const C: usize = 119;",
			"const ROOT_PW: usize = 1 << 23;",
			"const G: M = M::new(3);",
			"const ROOT: M = G.pow(C);",
			"const ROOT_1: M = ROOT.inv();",
			"type M = Mod;",
			"",
			"// from https://cp-algorithms.com/algebra/fft.html#number-theoretic-transform",
			"pub fn fft(a: &mut Vec<M>, invert: bool) {",
			"    let n = a.len();",
			"",
			"    let mut j = 0;",
			"    for i in 1..n {",
			"        let mut bit = n >> 1;",
			"        while j & bit != 0 {",
			"            j ^= bit;",
			"            bit >>= 1;",
			"        }",
			"        j ^= bit;",
			"        if i < j {",
			"            a.swap(i, j);",
			"        }",
			"    }",
			"",
			"    let mut len = 2;",
			"    while len <= n {",
			"        let mut wlen = if invert { ROOT_1 } else { ROOT };",
			"        let mut i = len;",
			"        while i < ROOT_PW {",
			"            wlen *= wlen;",
			"            i <<= 1;",
			"        }",
			"        for i in (0..n).step_by(len) {",
			"            let mut w = M::ONE;",
			"            for j in 0..len / 2 {",
			"                let u = a[i + j];",
			"                let v = a[i + j + len / 2] * w;",
			"                a[i + j] = u + v;",
			"                a[i + j + len / 2] = u - v;",
			"                w *= wlen;",
			"            }",
			"        }",
			"",
			"        len <<= 1;",
			"    }",
			"",
			"    if invert {",
			"        let n_1 = M::new(n).inv();",
			"        for x in a {",
			"            *x *= n_1;",
			"        }",
			"    }",
			"}",
			"",
			"pub fn multiply(a: &Vec<M>, b: &Vec<M>) -> Vec<M> {",
			"    let mut fa = a.clone();",
			"    let mut fb = b.clone();",
			"    let n = (a.len() + b.len()).next_power_of_two();",
			"",
			"    fa.resize(n, M::ZERO);",
			"    fb.resize(n, M::ZERO);",
			"",
			"    fft(&mut fa, false);",
			"    fft(&mut fb, false);",
			"    for (fai, fbi) in fa.iter_mut().zip(fb) {",
			"        *fai *= fbi;",
			"    }",
			"    fft(&mut fa, true);",
			"",
			"    fa",
			"}"
		]
	},
	"count_divisors": {
		"scope": "rust",
		"prefix": "count_divisors",
		"body": [
			"$0",
			"// requires sqrt, is_prime",
			"",
			"pub struct CountDivisors {",
			"    primes: Vec<U>,",
			"}",
			"impl CountDivisors {",
			"    pub fn new() -> Self {",
			"        let n = 1_000_006;",
			"        let mut lp = vec![0; n + 1];",
			"        let mut pr = vec![];",
			"        for i in 2..=n {",
			"            if lp[i] == 0 {",
			"                lp[i] = i;",
			"                pr.push(i);",
			"            }",
			"            let mut j = 0;",
			"            while i * pr[j] <= n {",
			"                lp[i * pr[j]] = pr[j];",
			"                if pr[j] == lp[i] {",
			"                    break;",
			"                }",
			"                j += 1;",
			"            }",
			"        }",
			"        Self { primes: pr }",
			"    }",
			"    pub fn count(&self, mut n: U) -> U {",
			"        if n == 1 {",
			"            return 1;",
			"        }",
			"        let mut ans = 1;",
			"        for p in &self.primes {",
			"            if p * p * p > n {",
			"                break;",
			"            }",
			"            let mut count = 1;",
			"            while n % p == 0 {",
			"                n /= p;",
			"                count += 1;",
			"            }",
			"            ans *= count;",
			"        }",
			"        if is_prime(n) {",
			"            ans * 2",
			"        } else if sqrt(n as _).is_some_and(|s| is_prime(s as U)) {",
			"            ans * 3",
			"        } else if n != 1 {",
			"            ans * 4",
			"        } else {",
			"            ans",
			"        }",
			"    }",
			"}"
		]
	},
	"seg2_tree": {
		"scope": "rust",
		"prefix": "seg2_tree",
		"body": [
			"$0",
			"pub struct SegmentTree {",
			"    pub tree: Vec<SegmentTreeType>,",
			"    pub n: usize",
			"}",
			"impl SegmentTree {",
			"    pub fn new(input: &[SegmentTreeType]) -> Self {",
			"        let n = input.len();",
			"        let mut tree = vec![DEFAULT_SEGMENT_TREE_TYPE; n << 1];",
			"        tree[n..n + input.len()].clone_from_slice(input);",
			"        for i in (1..n).rev() {",
			"            tree[i] = transform(&tree[i << 1], &tree[(i << 1) | 1]);",
			"        }",
			"        Self { tree, n }",
			"    }",
			"",
			"    /// Query the segment tree for the range [l, r).",
			"    pub fn query(&self, mut l: usize, mut r: usize) -> Option<SegmentTreeType> {",
			"        let mut res: Option<SegmentTreeType> = None;",
			"        l += self.n;",
			"        r += self.n;",
			"        while l < r {",
			"            if l & 1 == 1 {",
			"                res = Some(if let Some(v) = res {",
			"                    transform(&v, &self.tree[l])",
			"                } else {",
			"                    self.tree[l]",
			"                });",
			"                l += 1;",
			"            }",
			"            if r & 1 == 1 {",
			"                r -= 1;",
			"                res = Some(if let Some(v) = res {",
			"                    transform(&self.tree[r], &v)",
			"                } else {",
			"                    self.tree[r]",
			"                });",
			"            }",
			"            l >>= 1;",
			"            r >>= 1;",
			"        }",
			"        res",
			"    }",
			"",
			"    pub fn update(&mut self, i: usize, v: SegmentTreeType) {",
			"        let n = (self.tree.len() + 1) / 2;",
			"        let mut i = i + n;",
			"        self.tree[i] += v;",
			"        while i > 1 {",
			"            i >>= 1;",
			"            self.tree[i] = transform(&self.tree[i << 1], &self.tree[(i << 1) | 1]);",
			"        }",
			"    }",
			"}",
			"",
			"pub type SegmentTreeType = $1;",
			"const DEFAULT_SEGMENT_TREE_TYPE: SegmentTreeType = $2;",
			"",
			"#[inline(always)]",
			"pub fn transform(lhs: &SegmentTreeType, rhs: &SegmentTreeType) -> SegmentTreeType {",
			"    $3",
			"}"
		]
	},
	"is_prime": {
		"scope": "rust",
		"prefix": "is_prime",
		"body": [
			"$0",
			"fn pow(a: usize, mut e: usize, n: usize) -> usize {",
			"    let mut res = 1;",
			"    let mut cur = a;",
			"    while e > 0 {",
			"        if e & 1 == 1 {",
			"            res = ((res as u128 * cur as u128) % n as u128) as usize;",
			"        }",
			"        cur = ((cur as u128 * cur as u128) % n as u128) as usize;",
			"        e >>= 1;",
			"    }",
			"    res",
			"}",
			"",
			"fn is_prime(n: U) -> bool {",
			"    if n == 1 {",
			"        false",
			"    } else if n == 2 {",
			"        true",
			"    } else if n == 3 {",
			"        true",
			"    } else if n & 1 == 0 {",
			"        false",
			"    } else {",
			"        let mut rng = Rng::new();",
			"        let s = (n - 1).trailing_zeros();",
			"        let d = (n - 1) >> s;",
			"        for _ in 0..100 {",
			"            let a = rng.next() as U % (n - 4) + 2;",
			"            let mut x = pow(a, d, n);",
			"            for _ in 0..s {",
			"                let y = ((x as u128 * x as u128) % n as u128) as usize;",
			"                if y == 1 && x != 1 && x != n - 1 {",
			"                    return false;",
			"                }",
			"                x = y;",
			"            }",
			"            if x != 1 {",
			"                return false;",
			"            }",
			"        }",
			"        true",
			"    }",
			"}"
		]
	},
	"sqrt": {
		"scope": "rust",
		"prefix": "sqrt",
		"body": [
			"$0",
			"use std::cmp::Ordering;",
			"",
			"/// Tries to calculate the square root of x, `None` if `x` is not a perfect square",
			"pub fn sqrt(x: u128) -> Option<u128> {",
			"    let mut l = 0;",
			"    let mut r = x + 1;",
			"    while l <= r {",
			"        let mid = (l + r) >> 1;",
			"        match (mid.saturating_mul(mid)).cmp(&x) {",
			"            Ordering::Equal => return Some(mid),",
			"            Ordering::Greater => r = mid - 1,",
			"            Ordering::Less => l = mid + 1,",
			"        }",
			"    }",
			"    None",
			"}"
		]
	},
	"comparator": {
		"scope": "rust",
		"prefix": "comparator",
		"body": [
			"$0",
			"#[derive(Debug)]",
			"struct Comparator(compile_error!());",
			"impl PartialEq for Comparator {",
			"    fn eq(&self, other: &Self) -> bool {",
			"        self.cmp(other).is_eq()",
			"    }",
			"}",
			"impl Eq for Comparator {}",
			"impl Ord for Comparator {",
			"    fn cmp(&self, other: &Self) -> std::cmp::Ordering {",
			"        todo!()",
			"    }",
			"}",
			"impl PartialOrd for Comparator {",
			"    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {",
			"        Some(self.cmp(other))",
			"    }",
			"}"
		]
	},
	"dfs_low_mem": {
		"scope": "rust",
		"prefix": "dfs_low_mem",
		"body": [
			"$0",
			"pub fn dfs(u: U, edges: &Vec<Vec<U>>, dfsin: &mut Vec<U>, dfsout: &mut Vec<U>, t: &mut U) {",
			"    let mut todo = vec![(u, vec![])];",
			"    while let Some((u, mut vv)) = todo.pop() {",
			"        dfsin[u] = *t;",
			"        *t += 1;",
			"",
			"        if edges[u].is_empty() {",
			"            dfsout[u] = *t;",
			"            *t += 1;",
			"            for v in vv.into_iter().rev() {",
			"                dfsout[v] = *t;",
			"                *t += 1;",
			"            }",
			"        } else {",
			"            vv.push(u);",
			"            let mut todo2 = vec![];",
			"            for v in &edges[u] {",
			"                if *v == edges[u].l() {",
			"                    todo2.push((*v, vv));",
			"                    break;",
			"                } else {",
			"                    todo2.push((*v, vec![]));",
			"                }",
			"            }",
			"            todo2.reverse();",
			"            todo.extend(todo2);",
			"        }",
			"    }",
			"}"
		]
	},
	"pattern_matching_wildcards": {
		"scope": "rust",
		"prefix": "pattern_matching_wildcards",
		"body": [
			"$0",
			"// requires ntt, modint",
			"",
			"/// `a`, `b` lowercase latin character or wildcard",
			"/// `a`, `b` lowercase latin character or wildcard",
			"pub fn wildcard_match(a: &[char], b: &[char], wildcard: char) -> Vec<bool> {",
			"    let mut rng = Rng::new();",
			"    let enc = (0..26)",
			"        .map(|_| M::new(rng.next() as U))",
			"        .map(|x| if x.0 < 5 { x + 5 } else { x })",
			"        .map(|x| (x, M::ONE / x))",
			"        .cv();",
			"    let ap = a",
			"        .iter()",
			"        .copied()",
			"        .map(|c| {",
			"            if c == wildcard {",
			"                M::ZERO",
			"            } else {",
			"                enc[c as usize - b'a' as usize].0",
			"            }",
			"        })",
			"        .cv();",
			"    let bp = b",
			"        .iter()",
			"        .copied()",
			"        .map(|c| {",
			"            if c == wildcard {",
			"                M::ZERO",
			"            } else {",
			"                enc[c as usize - b'a' as usize].1",
			"            }",
			"        })",
			"        .rev()",
			"        .cv();",
			"    let duplicates = multiply(",
			"        &a.iter()",
			"            .copied()",
			"            .map(|c| if c == wildcard { M::ONE } else { M::ZERO })",
			"            .cv(),",
			"        &b.iter()",
			"            .copied()",
			"            .map(|c| if c == wildcard { M::ONE } else { M::ZERO })",
			"            .rev()",
			"            .cv(),",
			"    );",
			"    let result = multiply(&ap, &bp).into_iter().map(|x| x.0).cv();",
			"    let mut prefix_wildcard = vec![0];",
			"    for c in a.iter().copied() {",
			"        prefix_wildcard.push(prefix_wildcard.l() + if c == wildcard { 1 } else { 0 });",
			"    }",
			"    let b_wildcard = b.iter().copied().filter(|c| c == &wildcard).count();",
			"    let mut out = Vec::new();",
			"    for i in b.len() - 1..a.len() {",
			"        let wildcards = b_wildcard + (prefix_wildcard[i + 1] - prefix_wildcard[i - (b.len() - 1)]);",
			"        out.push(",
			"            result[i] as I",
			"                == b.len() as I + duplicates.get(i).map(|x| x.0).unwrap_or(0) as I - wildcards as I,",
			"        );",
			"    }",
			"    out",
			"}"
		]
	}
}
